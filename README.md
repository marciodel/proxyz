# proxyz

[![GoDoc](https://godoc.org/github.com/roy2220/proxyz?status.svg)](https://godoc.org/github.com/roy2220/proxyz) [![Build Status](https://travis-ci.com/roy2220/proxyz.svg?branch=master)](https://travis-ci.com/roy2220/proxyz) [![Coverage Status](https://codecov.io/gh/roy2220/proxyz/branch/master/graph/badge.svg)](https://codecov.io/gh/roy2220/proxyz)

ProxyZ is a proxy generator for Go.

It analyzes the [method sets](https://golang.org/ref/spec#Method_sets) of Go types from the sources and then generates code of wrapper structures for the types, which work as proxies. You might intercept method calls via the the proxies in order to check/modify the arguments and results of the method calls, even bypass the method calls.

## Features
- Supports method call interception
- Supports embedded structures/interfaces analysis
- Supports variadic function analysis

## Installation

```shell
go get github.com/roy2220/proxyz/...
go install github.com/roy2220/proxyz/cmd/proxyz
```

## Usage

```
proxyz [--format] [--write FILE] IPKG ITYPE OPKG OTYPE

Positional arguments:
  IPKG                   input package path in Go
  ITYPE                  input type name in Go
  OPKG                   output package path in Go
  OTYPE                  output type name in Go

Options:
  --format, -f           format output [default: true]
  --write FILE, -w FILE
                         write output to file inside output package directory
  --help, -h             display this help and exit
```

## Quick Start

### 1. Create new file `calc.go`

```go
package main

import "fmt"

type calc struct {
}

func (calc) Sum(x, y int) string {
        s := fmt.Sprintf("%d + %d = %d", x, y, x+y)
        return s
}

func main() {
        var c calc
        s := c.Sum(1, 2)
        fmt.Println(s)
        // Output: 1 + 2 = 3
}
```

### 2. Generate proxy

```shell
"$(go env GOPATH)/bin/proxyz" . calc . calcProxy -w calcproxy.go
# output written to file "calcproxy.go"
```

See [Usage](#usage) for explanation

### 3. Update file `calc.go`

```go
package main

import (
        "fmt"
        "strings"

        "github.com/roy2220/proxyz"
)

type calc struct {
}

func (calc) Sum(x, y int) string {
        s := fmt.Sprintf("%d + %d = %d", x, y, x+y)
        return s
}

func main() {
        var c calc
        // new a proxy.
        cp := newCalcProxy(&c) // function `newCalcProxy` is generated by proxyz.

        // add a method call interceptor.
        cp.XxxInterceptMethodCall(
                // method index, indicating the method `Sum` here.
                calcProxySum, // constant `calcProxySum` is generated by proxyz.

                // method call intercepting function.
                func(mc proxyz.MethodCall) {
                        // modify the second argument `y`, whose index is 1.
                        y := mc.GetArg(1).(int)
                        y += 100
                        mc.SetArg(1, y)

                        // forward the method call to the next interceptor, if any,
                        // or forward to the undelying object `Calc`.
                        mc.Forward() // Without this, the method call ceases here.

                        // modify the first (only) result, whose index is 0.
                        s := mc.GetResult(0).(string)
                        s = strings.ReplaceAll(s, "=", "!=")
                        mc.SetResult(0, s)
                },
        )

        // call Sum() from the proxy.
        s := cp.Sum(1, 2)

        fmt.Println(s)
        // Output: 1 + 102 != 103
}
```

### 4. Run the code

```shell
go run calc.go calcproxy.go
# 1 + 102 != 103
```

See [examples/clac](./examples/clac) for the complete code
