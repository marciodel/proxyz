// Code generated by proxyz. DO NOT EDIT.
package main

import (
	proxyz "github.com/roy2220/proxyz"
)

type calcProxy struct {
	proxyz.XxxProxyBase
	*calc
}

var _ = (proxyz.Proxy)((*calcProxy)(nil))

func newCalcProxy(underlying *calc) *calcProxy {
	return &calcProxy{
		calc: underlying,
	}
}

const calcProxySum = 0

type calcProxySumCall struct {
	Arg0    int
	Arg1    int
	Result0 string

	callee               *calc
	interceptors         []proxyz.MethodCallInterceptor
	nextInterceptorIndex int
}

var _ = (proxyz.MethodCall)((*calcProxySumCall)(nil))

func (mc *calcProxySumCall) Forward() {
	if interceptor, ok := mc.getNextInterceptor(); ok {
		interceptor(mc)
		return
	}

	mc.Result0 = mc.callee.Sum(mc.Arg0, mc.Arg1)
}

func (mc *calcProxySumCall) GetArg(argIndex int) interface{} {
	switch argIndex {
	case 0:
		return mc.Arg0
	case 1:
		return mc.Arg1
	default:
		panic("arg index out of range")
	}
}

func (mc *calcProxySumCall) SetArg(argIndex int, arg interface{}) {
	switch argIndex {
	case 0:
		mc.Arg0 = arg.(int)
	case 1:
		mc.Arg1 = arg.(int)
	default:
		panic("arg index out of range")
	}
}

func (mc *calcProxySumCall) GetResult(resultIndex int) interface{} {
	switch resultIndex {
	case 0:
		return mc.Result0
	default:
		panic("result index out of range")
	}
}

func (mc *calcProxySumCall) SetResult(resultIndex int, result interface{}) {
	switch resultIndex {
	case 0:
		mc.Result0 = result.(string)
	default:
		panic("result index out of range")
	}
}

func (mc *calcProxySumCall) MethodName() string   { return "Sum" }
func (mc *calcProxySumCall) MethodIndex() int     { return calcProxySum }
func (mc *calcProxySumCall) NumberOfArgs() int    { return 2 }
func (mc *calcProxySumCall) NumberOfResults() int { return 1 }

func (mc *calcProxySumCall) getNextInterceptor() (proxyz.MethodCallInterceptor, bool) {
	if i := mc.nextInterceptorIndex; i < len(mc.interceptors) {
		mc.nextInterceptorIndex++
		return mc.interceptors[i], true
	}

	return nil, false
}

func (p *calcProxy) Sum(_x_ int, _y_ int) string {
	methodCallInterceptors := p.XxxGetMethodCallInterceptors(calcProxySum)

	if len(methodCallInterceptors) == 0 {
		return p.calc.Sum(_x_, _y_)
	}

	methodCall := calcProxySumCall{
		Arg0: _x_,
		Arg1: _y_,

		callee:       p.calc,
		interceptors: methodCallInterceptors,
	}

	methodCall.Forward()
	return methodCall.Result0
}

func (p *calcProxy) XxxNumberOfMethods() int { return 1 }
