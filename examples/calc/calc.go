package main

import (
	"fmt"
	"strings"

	"github.com/roy2220/proxyz"
)

type calc struct {
}

func (calc) Sum(x, y int) string {
	s := fmt.Sprintf("%d + %d = %d", x, y, x+y)
	return s
}

func main() {
	var c calc
	// new a proxy.
	cp := newCalcProxy(&c) // function `newCalcProxy` is generated by proxyz.

	// add a method call interceptor.
	cp.XxxInterceptMethodCall(
		// method index, indicating the method `Sum` here.
		calcProxySum, // constant `calcProxySum` is generated by proxyz.

		// method call intercepting function.
		func(mc proxyz.MethodCall) {
			// modify the second argument `y`, whose index is 1.
			y := mc.GetArg(1).(int)
			y += 100
			mc.SetArg(1, y)

			// forward the method call to the next interceptor, if any,
			// or forward to the underlying object `calc`.
			// NOTE: without this call, the method `Sum` will NOT be
			//       actually called, and no result provided.
			mc.Forward()

			// modify the first (only) result, whose index is 0.
			s := mc.GetResult(0).(string)
			s = strings.ReplaceAll(s, "=", "!=")
			mc.SetResult(0, s)
		},
	)

	// call Sum() from the proxy.
	s := cp.Sum(1, 2)

	fmt.Println(s)
	// Output: 1 + 102 != 103
}
