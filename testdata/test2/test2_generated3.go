// Code generated by proxyz. DO NOT EDIT.
package main

import (
	proxyz "github.com/roy2220/proxyz"
	testing "testing"
)

type TPWrap struct {
	proxyz.XxxProxyBase
	testing.TB
}

var _ = (proxyz.Proxy)((*TPWrap)(nil))

func NewTPWrap(underlying testing.TB) *TPWrap {
	return &TPWrap{
		TB: underlying,
	}
}

const TPWrapCleanup = 0

type TPWrapCleanupCall struct {
	Arg0 func()

	callee               testing.TB
	interceptors         []proxyz.MethodCallInterceptor
	nextInterceptorIndex int
}

var _ = (proxyz.MethodCall)((*TPWrapCleanupCall)(nil))

func (mc *TPWrapCleanupCall) Forward() {
	if interceptor, ok := mc.getNextInterceptor(); ok {
		interceptor(mc)
		return
	}

	mc.callee.Cleanup(mc.Arg0)
}

func (mc *TPWrapCleanupCall) GetArg(argIndex int) interface{} {
	switch argIndex {
	case 0:
		return mc.Arg0
	default:
		panic("arg index out of range")
	}
}

func (mc *TPWrapCleanupCall) SetArg(argIndex int, arg interface{}) {
	switch argIndex {
	case 0:
		mc.Arg0 = arg.(func())
	default:
		panic("arg index out of range")
	}
}

func (mc *TPWrapCleanupCall) GetResult(resultIndex int) interface{} {
	switch resultIndex {
	default:
		panic("result index out of range")
	}
}

func (mc *TPWrapCleanupCall) SetResult(resultIndex int, result interface{}) {
	switch resultIndex {
	default:
		panic("result index out of range")
	}
}

func (mc *TPWrapCleanupCall) MethodName() string   { return "Cleanup" }
func (mc *TPWrapCleanupCall) MethodIndex() int     { return TPWrapCleanup }
func (mc *TPWrapCleanupCall) NumberOfArgs() int    { return 1 }
func (mc *TPWrapCleanupCall) NumberOfResults() int { return 0 }

func (mc *TPWrapCleanupCall) getNextInterceptor() (proxyz.MethodCallInterceptor, bool) {
	if i := mc.nextInterceptorIndex; i < len(mc.interceptors) {
		mc.nextInterceptorIndex++
		return mc.interceptors[i], true
	}

	return nil, false
}

func (p *TPWrap) Cleanup(arg0 func()) {
	methodCallInterceptors := p.XxxGetMethodCallInterceptors(TPWrapCleanup)

	if len(methodCallInterceptors) == 0 {
		p.TB.Cleanup(arg0)
	}

	methodCall := TPWrapCleanupCall{
		Arg0: arg0,

		callee:       p.TB,
		interceptors: methodCallInterceptors,
	}

	methodCall.Forward()
}

const TPWrapError = 1

type TPWrapErrorCall struct {
	Arg0 []interface{}

	callee               testing.TB
	interceptors         []proxyz.MethodCallInterceptor
	nextInterceptorIndex int
}

var _ = (proxyz.MethodCall)((*TPWrapErrorCall)(nil))

func (mc *TPWrapErrorCall) Forward() {
	if interceptor, ok := mc.getNextInterceptor(); ok {
		interceptor(mc)
		return
	}

	mc.callee.Error(mc.Arg0...)
}

func (mc *TPWrapErrorCall) GetArg(argIndex int) interface{} {
	switch argIndex {
	case 0:
		return mc.Arg0
	default:
		panic("arg index out of range")
	}
}

func (mc *TPWrapErrorCall) SetArg(argIndex int, arg interface{}) {
	switch argIndex {
	case 0:
		mc.Arg0 = arg.([]interface{})
	default:
		panic("arg index out of range")
	}
}

func (mc *TPWrapErrorCall) GetResult(resultIndex int) interface{} {
	switch resultIndex {
	default:
		panic("result index out of range")
	}
}

func (mc *TPWrapErrorCall) SetResult(resultIndex int, result interface{}) {
	switch resultIndex {
	default:
		panic("result index out of range")
	}
}

func (mc *TPWrapErrorCall) MethodName() string   { return "Error" }
func (mc *TPWrapErrorCall) MethodIndex() int     { return TPWrapError }
func (mc *TPWrapErrorCall) NumberOfArgs() int    { return 1 }
func (mc *TPWrapErrorCall) NumberOfResults() int { return 0 }

func (mc *TPWrapErrorCall) getNextInterceptor() (proxyz.MethodCallInterceptor, bool) {
	if i := mc.nextInterceptorIndex; i < len(mc.interceptors) {
		mc.nextInterceptorIndex++
		return mc.interceptors[i], true
	}

	return nil, false
}

func (p *TPWrap) Error(_args_ ...interface{}) {
	methodCallInterceptors := p.XxxGetMethodCallInterceptors(TPWrapError)

	if len(methodCallInterceptors) == 0 {
		p.TB.Error(_args_...)
	}

	methodCall := TPWrapErrorCall{
		Arg0: _args_,

		callee:       p.TB,
		interceptors: methodCallInterceptors,
	}

	methodCall.Forward()
}

const TPWrapErrorf = 2

type TPWrapErrorfCall struct {
	Arg0 string
	Arg1 []interface{}

	callee               testing.TB
	interceptors         []proxyz.MethodCallInterceptor
	nextInterceptorIndex int
}

var _ = (proxyz.MethodCall)((*TPWrapErrorfCall)(nil))

func (mc *TPWrapErrorfCall) Forward() {
	if interceptor, ok := mc.getNextInterceptor(); ok {
		interceptor(mc)
		return
	}

	mc.callee.Errorf(mc.Arg0, mc.Arg1...)
}

func (mc *TPWrapErrorfCall) GetArg(argIndex int) interface{} {
	switch argIndex {
	case 0:
		return mc.Arg0
	case 1:
		return mc.Arg1
	default:
		panic("arg index out of range")
	}
}

func (mc *TPWrapErrorfCall) SetArg(argIndex int, arg interface{}) {
	switch argIndex {
	case 0:
		mc.Arg0 = arg.(string)
	case 1:
		mc.Arg1 = arg.([]interface{})
	default:
		panic("arg index out of range")
	}
}

func (mc *TPWrapErrorfCall) GetResult(resultIndex int) interface{} {
	switch resultIndex {
	default:
		panic("result index out of range")
	}
}

func (mc *TPWrapErrorfCall) SetResult(resultIndex int, result interface{}) {
	switch resultIndex {
	default:
		panic("result index out of range")
	}
}

func (mc *TPWrapErrorfCall) MethodName() string   { return "Errorf" }
func (mc *TPWrapErrorfCall) MethodIndex() int     { return TPWrapErrorf }
func (mc *TPWrapErrorfCall) NumberOfArgs() int    { return 2 }
func (mc *TPWrapErrorfCall) NumberOfResults() int { return 0 }

func (mc *TPWrapErrorfCall) getNextInterceptor() (proxyz.MethodCallInterceptor, bool) {
	if i := mc.nextInterceptorIndex; i < len(mc.interceptors) {
		mc.nextInterceptorIndex++
		return mc.interceptors[i], true
	}

	return nil, false
}

func (p *TPWrap) Errorf(_format_ string, _args_ ...interface{}) {
	methodCallInterceptors := p.XxxGetMethodCallInterceptors(TPWrapErrorf)

	if len(methodCallInterceptors) == 0 {
		p.TB.Errorf(_format_, _args_...)
	}

	methodCall := TPWrapErrorfCall{
		Arg0: _format_,
		Arg1: _args_,

		callee:       p.TB,
		interceptors: methodCallInterceptors,
	}

	methodCall.Forward()
}

const TPWrapFail = 3

type TPWrapFailCall struct {
	callee               testing.TB
	interceptors         []proxyz.MethodCallInterceptor
	nextInterceptorIndex int
}

var _ = (proxyz.MethodCall)((*TPWrapFailCall)(nil))

func (mc *TPWrapFailCall) Forward() {
	if interceptor, ok := mc.getNextInterceptor(); ok {
		interceptor(mc)
		return
	}

	mc.callee.Fail()
}

func (mc *TPWrapFailCall) GetArg(argIndex int) interface{} {
	switch argIndex {
	default:
		panic("arg index out of range")
	}
}

func (mc *TPWrapFailCall) SetArg(argIndex int, arg interface{}) {
	switch argIndex {
	default:
		panic("arg index out of range")
	}
}

func (mc *TPWrapFailCall) GetResult(resultIndex int) interface{} {
	switch resultIndex {
	default:
		panic("result index out of range")
	}
}

func (mc *TPWrapFailCall) SetResult(resultIndex int, result interface{}) {
	switch resultIndex {
	default:
		panic("result index out of range")
	}
}

func (mc *TPWrapFailCall) MethodName() string   { return "Fail" }
func (mc *TPWrapFailCall) MethodIndex() int     { return TPWrapFail }
func (mc *TPWrapFailCall) NumberOfArgs() int    { return 0 }
func (mc *TPWrapFailCall) NumberOfResults() int { return 0 }

func (mc *TPWrapFailCall) getNextInterceptor() (proxyz.MethodCallInterceptor, bool) {
	if i := mc.nextInterceptorIndex; i < len(mc.interceptors) {
		mc.nextInterceptorIndex++
		return mc.interceptors[i], true
	}

	return nil, false
}

func (p *TPWrap) Fail() {
	methodCallInterceptors := p.XxxGetMethodCallInterceptors(TPWrapFail)

	if len(methodCallInterceptors) == 0 {
		p.TB.Fail()
	}

	methodCall := TPWrapFailCall{
		callee:       p.TB,
		interceptors: methodCallInterceptors,
	}

	methodCall.Forward()
}

const TPWrapFailNow = 4

type TPWrapFailNowCall struct {
	callee               testing.TB
	interceptors         []proxyz.MethodCallInterceptor
	nextInterceptorIndex int
}

var _ = (proxyz.MethodCall)((*TPWrapFailNowCall)(nil))

func (mc *TPWrapFailNowCall) Forward() {
	if interceptor, ok := mc.getNextInterceptor(); ok {
		interceptor(mc)
		return
	}

	mc.callee.FailNow()
}

func (mc *TPWrapFailNowCall) GetArg(argIndex int) interface{} {
	switch argIndex {
	default:
		panic("arg index out of range")
	}
}

func (mc *TPWrapFailNowCall) SetArg(argIndex int, arg interface{}) {
	switch argIndex {
	default:
		panic("arg index out of range")
	}
}

func (mc *TPWrapFailNowCall) GetResult(resultIndex int) interface{} {
	switch resultIndex {
	default:
		panic("result index out of range")
	}
}

func (mc *TPWrapFailNowCall) SetResult(resultIndex int, result interface{}) {
	switch resultIndex {
	default:
		panic("result index out of range")
	}
}

func (mc *TPWrapFailNowCall) MethodName() string   { return "FailNow" }
func (mc *TPWrapFailNowCall) MethodIndex() int     { return TPWrapFailNow }
func (mc *TPWrapFailNowCall) NumberOfArgs() int    { return 0 }
func (mc *TPWrapFailNowCall) NumberOfResults() int { return 0 }

func (mc *TPWrapFailNowCall) getNextInterceptor() (proxyz.MethodCallInterceptor, bool) {
	if i := mc.nextInterceptorIndex; i < len(mc.interceptors) {
		mc.nextInterceptorIndex++
		return mc.interceptors[i], true
	}

	return nil, false
}

func (p *TPWrap) FailNow() {
	methodCallInterceptors := p.XxxGetMethodCallInterceptors(TPWrapFailNow)

	if len(methodCallInterceptors) == 0 {
		p.TB.FailNow()
	}

	methodCall := TPWrapFailNowCall{
		callee:       p.TB,
		interceptors: methodCallInterceptors,
	}

	methodCall.Forward()
}

const TPWrapFailed = 5

type TPWrapFailedCall struct {
	Result0 bool

	callee               testing.TB
	interceptors         []proxyz.MethodCallInterceptor
	nextInterceptorIndex int
}

var _ = (proxyz.MethodCall)((*TPWrapFailedCall)(nil))

func (mc *TPWrapFailedCall) Forward() {
	if interceptor, ok := mc.getNextInterceptor(); ok {
		interceptor(mc)
		return
	}

	mc.Result0 = mc.callee.Failed()
}

func (mc *TPWrapFailedCall) GetArg(argIndex int) interface{} {
	switch argIndex {
	default:
		panic("arg index out of range")
	}
}

func (mc *TPWrapFailedCall) SetArg(argIndex int, arg interface{}) {
	switch argIndex {
	default:
		panic("arg index out of range")
	}
}

func (mc *TPWrapFailedCall) GetResult(resultIndex int) interface{} {
	switch resultIndex {
	case 0:
		return mc.Result0
	default:
		panic("result index out of range")
	}
}

func (mc *TPWrapFailedCall) SetResult(resultIndex int, result interface{}) {
	switch resultIndex {
	case 0:
		mc.Result0 = result.(bool)
	default:
		panic("result index out of range")
	}
}

func (mc *TPWrapFailedCall) MethodName() string   { return "Failed" }
func (mc *TPWrapFailedCall) MethodIndex() int     { return TPWrapFailed }
func (mc *TPWrapFailedCall) NumberOfArgs() int    { return 0 }
func (mc *TPWrapFailedCall) NumberOfResults() int { return 1 }

func (mc *TPWrapFailedCall) getNextInterceptor() (proxyz.MethodCallInterceptor, bool) {
	if i := mc.nextInterceptorIndex; i < len(mc.interceptors) {
		mc.nextInterceptorIndex++
		return mc.interceptors[i], true
	}

	return nil, false
}

func (p *TPWrap) Failed() bool {
	methodCallInterceptors := p.XxxGetMethodCallInterceptors(TPWrapFailed)

	if len(methodCallInterceptors) == 0 {
		return p.TB.Failed()
	}

	methodCall := TPWrapFailedCall{
		callee:       p.TB,
		interceptors: methodCallInterceptors,
	}

	methodCall.Forward()
	return methodCall.Result0
}

const TPWrapFatal = 6

type TPWrapFatalCall struct {
	Arg0 []interface{}

	callee               testing.TB
	interceptors         []proxyz.MethodCallInterceptor
	nextInterceptorIndex int
}

var _ = (proxyz.MethodCall)((*TPWrapFatalCall)(nil))

func (mc *TPWrapFatalCall) Forward() {
	if interceptor, ok := mc.getNextInterceptor(); ok {
		interceptor(mc)
		return
	}

	mc.callee.Fatal(mc.Arg0...)
}

func (mc *TPWrapFatalCall) GetArg(argIndex int) interface{} {
	switch argIndex {
	case 0:
		return mc.Arg0
	default:
		panic("arg index out of range")
	}
}

func (mc *TPWrapFatalCall) SetArg(argIndex int, arg interface{}) {
	switch argIndex {
	case 0:
		mc.Arg0 = arg.([]interface{})
	default:
		panic("arg index out of range")
	}
}

func (mc *TPWrapFatalCall) GetResult(resultIndex int) interface{} {
	switch resultIndex {
	default:
		panic("result index out of range")
	}
}

func (mc *TPWrapFatalCall) SetResult(resultIndex int, result interface{}) {
	switch resultIndex {
	default:
		panic("result index out of range")
	}
}

func (mc *TPWrapFatalCall) MethodName() string   { return "Fatal" }
func (mc *TPWrapFatalCall) MethodIndex() int     { return TPWrapFatal }
func (mc *TPWrapFatalCall) NumberOfArgs() int    { return 1 }
func (mc *TPWrapFatalCall) NumberOfResults() int { return 0 }

func (mc *TPWrapFatalCall) getNextInterceptor() (proxyz.MethodCallInterceptor, bool) {
	if i := mc.nextInterceptorIndex; i < len(mc.interceptors) {
		mc.nextInterceptorIndex++
		return mc.interceptors[i], true
	}

	return nil, false
}

func (p *TPWrap) Fatal(_args_ ...interface{}) {
	methodCallInterceptors := p.XxxGetMethodCallInterceptors(TPWrapFatal)

	if len(methodCallInterceptors) == 0 {
		p.TB.Fatal(_args_...)
	}

	methodCall := TPWrapFatalCall{
		Arg0: _args_,

		callee:       p.TB,
		interceptors: methodCallInterceptors,
	}

	methodCall.Forward()
}

const TPWrapFatalf = 7

type TPWrapFatalfCall struct {
	Arg0 string
	Arg1 []interface{}

	callee               testing.TB
	interceptors         []proxyz.MethodCallInterceptor
	nextInterceptorIndex int
}

var _ = (proxyz.MethodCall)((*TPWrapFatalfCall)(nil))

func (mc *TPWrapFatalfCall) Forward() {
	if interceptor, ok := mc.getNextInterceptor(); ok {
		interceptor(mc)
		return
	}

	mc.callee.Fatalf(mc.Arg0, mc.Arg1...)
}

func (mc *TPWrapFatalfCall) GetArg(argIndex int) interface{} {
	switch argIndex {
	case 0:
		return mc.Arg0
	case 1:
		return mc.Arg1
	default:
		panic("arg index out of range")
	}
}

func (mc *TPWrapFatalfCall) SetArg(argIndex int, arg interface{}) {
	switch argIndex {
	case 0:
		mc.Arg0 = arg.(string)
	case 1:
		mc.Arg1 = arg.([]interface{})
	default:
		panic("arg index out of range")
	}
}

func (mc *TPWrapFatalfCall) GetResult(resultIndex int) interface{} {
	switch resultIndex {
	default:
		panic("result index out of range")
	}
}

func (mc *TPWrapFatalfCall) SetResult(resultIndex int, result interface{}) {
	switch resultIndex {
	default:
		panic("result index out of range")
	}
}

func (mc *TPWrapFatalfCall) MethodName() string   { return "Fatalf" }
func (mc *TPWrapFatalfCall) MethodIndex() int     { return TPWrapFatalf }
func (mc *TPWrapFatalfCall) NumberOfArgs() int    { return 2 }
func (mc *TPWrapFatalfCall) NumberOfResults() int { return 0 }

func (mc *TPWrapFatalfCall) getNextInterceptor() (proxyz.MethodCallInterceptor, bool) {
	if i := mc.nextInterceptorIndex; i < len(mc.interceptors) {
		mc.nextInterceptorIndex++
		return mc.interceptors[i], true
	}

	return nil, false
}

func (p *TPWrap) Fatalf(_format_ string, _args_ ...interface{}) {
	methodCallInterceptors := p.XxxGetMethodCallInterceptors(TPWrapFatalf)

	if len(methodCallInterceptors) == 0 {
		p.TB.Fatalf(_format_, _args_...)
	}

	methodCall := TPWrapFatalfCall{
		Arg0: _format_,
		Arg1: _args_,

		callee:       p.TB,
		interceptors: methodCallInterceptors,
	}

	methodCall.Forward()
}

const TPWrapHelper = 8

type TPWrapHelperCall struct {
	callee               testing.TB
	interceptors         []proxyz.MethodCallInterceptor
	nextInterceptorIndex int
}

var _ = (proxyz.MethodCall)((*TPWrapHelperCall)(nil))

func (mc *TPWrapHelperCall) Forward() {
	if interceptor, ok := mc.getNextInterceptor(); ok {
		interceptor(mc)
		return
	}

	mc.callee.Helper()
}

func (mc *TPWrapHelperCall) GetArg(argIndex int) interface{} {
	switch argIndex {
	default:
		panic("arg index out of range")
	}
}

func (mc *TPWrapHelperCall) SetArg(argIndex int, arg interface{}) {
	switch argIndex {
	default:
		panic("arg index out of range")
	}
}

func (mc *TPWrapHelperCall) GetResult(resultIndex int) interface{} {
	switch resultIndex {
	default:
		panic("result index out of range")
	}
}

func (mc *TPWrapHelperCall) SetResult(resultIndex int, result interface{}) {
	switch resultIndex {
	default:
		panic("result index out of range")
	}
}

func (mc *TPWrapHelperCall) MethodName() string   { return "Helper" }
func (mc *TPWrapHelperCall) MethodIndex() int     { return TPWrapHelper }
func (mc *TPWrapHelperCall) NumberOfArgs() int    { return 0 }
func (mc *TPWrapHelperCall) NumberOfResults() int { return 0 }

func (mc *TPWrapHelperCall) getNextInterceptor() (proxyz.MethodCallInterceptor, bool) {
	if i := mc.nextInterceptorIndex; i < len(mc.interceptors) {
		mc.nextInterceptorIndex++
		return mc.interceptors[i], true
	}

	return nil, false
}

func (p *TPWrap) Helper() {
	methodCallInterceptors := p.XxxGetMethodCallInterceptors(TPWrapHelper)

	if len(methodCallInterceptors) == 0 {
		p.TB.Helper()
	}

	methodCall := TPWrapHelperCall{
		callee:       p.TB,
		interceptors: methodCallInterceptors,
	}

	methodCall.Forward()
}

const TPWrapLog = 9

type TPWrapLogCall struct {
	Arg0 []interface{}

	callee               testing.TB
	interceptors         []proxyz.MethodCallInterceptor
	nextInterceptorIndex int
}

var _ = (proxyz.MethodCall)((*TPWrapLogCall)(nil))

func (mc *TPWrapLogCall) Forward() {
	if interceptor, ok := mc.getNextInterceptor(); ok {
		interceptor(mc)
		return
	}

	mc.callee.Log(mc.Arg0...)
}

func (mc *TPWrapLogCall) GetArg(argIndex int) interface{} {
	switch argIndex {
	case 0:
		return mc.Arg0
	default:
		panic("arg index out of range")
	}
}

func (mc *TPWrapLogCall) SetArg(argIndex int, arg interface{}) {
	switch argIndex {
	case 0:
		mc.Arg0 = arg.([]interface{})
	default:
		panic("arg index out of range")
	}
}

func (mc *TPWrapLogCall) GetResult(resultIndex int) interface{} {
	switch resultIndex {
	default:
		panic("result index out of range")
	}
}

func (mc *TPWrapLogCall) SetResult(resultIndex int, result interface{}) {
	switch resultIndex {
	default:
		panic("result index out of range")
	}
}

func (mc *TPWrapLogCall) MethodName() string   { return "Log" }
func (mc *TPWrapLogCall) MethodIndex() int     { return TPWrapLog }
func (mc *TPWrapLogCall) NumberOfArgs() int    { return 1 }
func (mc *TPWrapLogCall) NumberOfResults() int { return 0 }

func (mc *TPWrapLogCall) getNextInterceptor() (proxyz.MethodCallInterceptor, bool) {
	if i := mc.nextInterceptorIndex; i < len(mc.interceptors) {
		mc.nextInterceptorIndex++
		return mc.interceptors[i], true
	}

	return nil, false
}

func (p *TPWrap) Log(_args_ ...interface{}) {
	methodCallInterceptors := p.XxxGetMethodCallInterceptors(TPWrapLog)

	if len(methodCallInterceptors) == 0 {
		p.TB.Log(_args_...)
	}

	methodCall := TPWrapLogCall{
		Arg0: _args_,

		callee:       p.TB,
		interceptors: methodCallInterceptors,
	}

	methodCall.Forward()
}

const TPWrapLogf = 10

type TPWrapLogfCall struct {
	Arg0 string
	Arg1 []interface{}

	callee               testing.TB
	interceptors         []proxyz.MethodCallInterceptor
	nextInterceptorIndex int
}

var _ = (proxyz.MethodCall)((*TPWrapLogfCall)(nil))

func (mc *TPWrapLogfCall) Forward() {
	if interceptor, ok := mc.getNextInterceptor(); ok {
		interceptor(mc)
		return
	}

	mc.callee.Logf(mc.Arg0, mc.Arg1...)
}

func (mc *TPWrapLogfCall) GetArg(argIndex int) interface{} {
	switch argIndex {
	case 0:
		return mc.Arg0
	case 1:
		return mc.Arg1
	default:
		panic("arg index out of range")
	}
}

func (mc *TPWrapLogfCall) SetArg(argIndex int, arg interface{}) {
	switch argIndex {
	case 0:
		mc.Arg0 = arg.(string)
	case 1:
		mc.Arg1 = arg.([]interface{})
	default:
		panic("arg index out of range")
	}
}

func (mc *TPWrapLogfCall) GetResult(resultIndex int) interface{} {
	switch resultIndex {
	default:
		panic("result index out of range")
	}
}

func (mc *TPWrapLogfCall) SetResult(resultIndex int, result interface{}) {
	switch resultIndex {
	default:
		panic("result index out of range")
	}
}

func (mc *TPWrapLogfCall) MethodName() string   { return "Logf" }
func (mc *TPWrapLogfCall) MethodIndex() int     { return TPWrapLogf }
func (mc *TPWrapLogfCall) NumberOfArgs() int    { return 2 }
func (mc *TPWrapLogfCall) NumberOfResults() int { return 0 }

func (mc *TPWrapLogfCall) getNextInterceptor() (proxyz.MethodCallInterceptor, bool) {
	if i := mc.nextInterceptorIndex; i < len(mc.interceptors) {
		mc.nextInterceptorIndex++
		return mc.interceptors[i], true
	}

	return nil, false
}

func (p *TPWrap) Logf(_format_ string, _args_ ...interface{}) {
	methodCallInterceptors := p.XxxGetMethodCallInterceptors(TPWrapLogf)

	if len(methodCallInterceptors) == 0 {
		p.TB.Logf(_format_, _args_...)
	}

	methodCall := TPWrapLogfCall{
		Arg0: _format_,
		Arg1: _args_,

		callee:       p.TB,
		interceptors: methodCallInterceptors,
	}

	methodCall.Forward()
}

const TPWrapName = 11

type TPWrapNameCall struct {
	Result0 string

	callee               testing.TB
	interceptors         []proxyz.MethodCallInterceptor
	nextInterceptorIndex int
}

var _ = (proxyz.MethodCall)((*TPWrapNameCall)(nil))

func (mc *TPWrapNameCall) Forward() {
	if interceptor, ok := mc.getNextInterceptor(); ok {
		interceptor(mc)
		return
	}

	mc.Result0 = mc.callee.Name()
}

func (mc *TPWrapNameCall) GetArg(argIndex int) interface{} {
	switch argIndex {
	default:
		panic("arg index out of range")
	}
}

func (mc *TPWrapNameCall) SetArg(argIndex int, arg interface{}) {
	switch argIndex {
	default:
		panic("arg index out of range")
	}
}

func (mc *TPWrapNameCall) GetResult(resultIndex int) interface{} {
	switch resultIndex {
	case 0:
		return mc.Result0
	default:
		panic("result index out of range")
	}
}

func (mc *TPWrapNameCall) SetResult(resultIndex int, result interface{}) {
	switch resultIndex {
	case 0:
		mc.Result0 = result.(string)
	default:
		panic("result index out of range")
	}
}

func (mc *TPWrapNameCall) MethodName() string   { return "Name" }
func (mc *TPWrapNameCall) MethodIndex() int     { return TPWrapName }
func (mc *TPWrapNameCall) NumberOfArgs() int    { return 0 }
func (mc *TPWrapNameCall) NumberOfResults() int { return 1 }

func (mc *TPWrapNameCall) getNextInterceptor() (proxyz.MethodCallInterceptor, bool) {
	if i := mc.nextInterceptorIndex; i < len(mc.interceptors) {
		mc.nextInterceptorIndex++
		return mc.interceptors[i], true
	}

	return nil, false
}

func (p *TPWrap) Name() string {
	methodCallInterceptors := p.XxxGetMethodCallInterceptors(TPWrapName)

	if len(methodCallInterceptors) == 0 {
		return p.TB.Name()
	}

	methodCall := TPWrapNameCall{
		callee:       p.TB,
		interceptors: methodCallInterceptors,
	}

	methodCall.Forward()
	return methodCall.Result0
}

const TPWrapSkip = 12

type TPWrapSkipCall struct {
	Arg0 []interface{}

	callee               testing.TB
	interceptors         []proxyz.MethodCallInterceptor
	nextInterceptorIndex int
}

var _ = (proxyz.MethodCall)((*TPWrapSkipCall)(nil))

func (mc *TPWrapSkipCall) Forward() {
	if interceptor, ok := mc.getNextInterceptor(); ok {
		interceptor(mc)
		return
	}

	mc.callee.Skip(mc.Arg0...)
}

func (mc *TPWrapSkipCall) GetArg(argIndex int) interface{} {
	switch argIndex {
	case 0:
		return mc.Arg0
	default:
		panic("arg index out of range")
	}
}

func (mc *TPWrapSkipCall) SetArg(argIndex int, arg interface{}) {
	switch argIndex {
	case 0:
		mc.Arg0 = arg.([]interface{})
	default:
		panic("arg index out of range")
	}
}

func (mc *TPWrapSkipCall) GetResult(resultIndex int) interface{} {
	switch resultIndex {
	default:
		panic("result index out of range")
	}
}

func (mc *TPWrapSkipCall) SetResult(resultIndex int, result interface{}) {
	switch resultIndex {
	default:
		panic("result index out of range")
	}
}

func (mc *TPWrapSkipCall) MethodName() string   { return "Skip" }
func (mc *TPWrapSkipCall) MethodIndex() int     { return TPWrapSkip }
func (mc *TPWrapSkipCall) NumberOfArgs() int    { return 1 }
func (mc *TPWrapSkipCall) NumberOfResults() int { return 0 }

func (mc *TPWrapSkipCall) getNextInterceptor() (proxyz.MethodCallInterceptor, bool) {
	if i := mc.nextInterceptorIndex; i < len(mc.interceptors) {
		mc.nextInterceptorIndex++
		return mc.interceptors[i], true
	}

	return nil, false
}

func (p *TPWrap) Skip(_args_ ...interface{}) {
	methodCallInterceptors := p.XxxGetMethodCallInterceptors(TPWrapSkip)

	if len(methodCallInterceptors) == 0 {
		p.TB.Skip(_args_...)
	}

	methodCall := TPWrapSkipCall{
		Arg0: _args_,

		callee:       p.TB,
		interceptors: methodCallInterceptors,
	}

	methodCall.Forward()
}

const TPWrapSkipNow = 13

type TPWrapSkipNowCall struct {
	callee               testing.TB
	interceptors         []proxyz.MethodCallInterceptor
	nextInterceptorIndex int
}

var _ = (proxyz.MethodCall)((*TPWrapSkipNowCall)(nil))

func (mc *TPWrapSkipNowCall) Forward() {
	if interceptor, ok := mc.getNextInterceptor(); ok {
		interceptor(mc)
		return
	}

	mc.callee.SkipNow()
}

func (mc *TPWrapSkipNowCall) GetArg(argIndex int) interface{} {
	switch argIndex {
	default:
		panic("arg index out of range")
	}
}

func (mc *TPWrapSkipNowCall) SetArg(argIndex int, arg interface{}) {
	switch argIndex {
	default:
		panic("arg index out of range")
	}
}

func (mc *TPWrapSkipNowCall) GetResult(resultIndex int) interface{} {
	switch resultIndex {
	default:
		panic("result index out of range")
	}
}

func (mc *TPWrapSkipNowCall) SetResult(resultIndex int, result interface{}) {
	switch resultIndex {
	default:
		panic("result index out of range")
	}
}

func (mc *TPWrapSkipNowCall) MethodName() string   { return "SkipNow" }
func (mc *TPWrapSkipNowCall) MethodIndex() int     { return TPWrapSkipNow }
func (mc *TPWrapSkipNowCall) NumberOfArgs() int    { return 0 }
func (mc *TPWrapSkipNowCall) NumberOfResults() int { return 0 }

func (mc *TPWrapSkipNowCall) getNextInterceptor() (proxyz.MethodCallInterceptor, bool) {
	if i := mc.nextInterceptorIndex; i < len(mc.interceptors) {
		mc.nextInterceptorIndex++
		return mc.interceptors[i], true
	}

	return nil, false
}

func (p *TPWrap) SkipNow() {
	methodCallInterceptors := p.XxxGetMethodCallInterceptors(TPWrapSkipNow)

	if len(methodCallInterceptors) == 0 {
		p.TB.SkipNow()
	}

	methodCall := TPWrapSkipNowCall{
		callee:       p.TB,
		interceptors: methodCallInterceptors,
	}

	methodCall.Forward()
}

const TPWrapSkipf = 14

type TPWrapSkipfCall struct {
	Arg0 string
	Arg1 []interface{}

	callee               testing.TB
	interceptors         []proxyz.MethodCallInterceptor
	nextInterceptorIndex int
}

var _ = (proxyz.MethodCall)((*TPWrapSkipfCall)(nil))

func (mc *TPWrapSkipfCall) Forward() {
	if interceptor, ok := mc.getNextInterceptor(); ok {
		interceptor(mc)
		return
	}

	mc.callee.Skipf(mc.Arg0, mc.Arg1...)
}

func (mc *TPWrapSkipfCall) GetArg(argIndex int) interface{} {
	switch argIndex {
	case 0:
		return mc.Arg0
	case 1:
		return mc.Arg1
	default:
		panic("arg index out of range")
	}
}

func (mc *TPWrapSkipfCall) SetArg(argIndex int, arg interface{}) {
	switch argIndex {
	case 0:
		mc.Arg0 = arg.(string)
	case 1:
		mc.Arg1 = arg.([]interface{})
	default:
		panic("arg index out of range")
	}
}

func (mc *TPWrapSkipfCall) GetResult(resultIndex int) interface{} {
	switch resultIndex {
	default:
		panic("result index out of range")
	}
}

func (mc *TPWrapSkipfCall) SetResult(resultIndex int, result interface{}) {
	switch resultIndex {
	default:
		panic("result index out of range")
	}
}

func (mc *TPWrapSkipfCall) MethodName() string   { return "Skipf" }
func (mc *TPWrapSkipfCall) MethodIndex() int     { return TPWrapSkipf }
func (mc *TPWrapSkipfCall) NumberOfArgs() int    { return 2 }
func (mc *TPWrapSkipfCall) NumberOfResults() int { return 0 }

func (mc *TPWrapSkipfCall) getNextInterceptor() (proxyz.MethodCallInterceptor, bool) {
	if i := mc.nextInterceptorIndex; i < len(mc.interceptors) {
		mc.nextInterceptorIndex++
		return mc.interceptors[i], true
	}

	return nil, false
}

func (p *TPWrap) Skipf(_format_ string, _args_ ...interface{}) {
	methodCallInterceptors := p.XxxGetMethodCallInterceptors(TPWrapSkipf)

	if len(methodCallInterceptors) == 0 {
		p.TB.Skipf(_format_, _args_...)
	}

	methodCall := TPWrapSkipfCall{
		Arg0: _format_,
		Arg1: _args_,

		callee:       p.TB,
		interceptors: methodCallInterceptors,
	}

	methodCall.Forward()
}

const TPWrapSkipped = 15

type TPWrapSkippedCall struct {
	Result0 bool

	callee               testing.TB
	interceptors         []proxyz.MethodCallInterceptor
	nextInterceptorIndex int
}

var _ = (proxyz.MethodCall)((*TPWrapSkippedCall)(nil))

func (mc *TPWrapSkippedCall) Forward() {
	if interceptor, ok := mc.getNextInterceptor(); ok {
		interceptor(mc)
		return
	}

	mc.Result0 = mc.callee.Skipped()
}

func (mc *TPWrapSkippedCall) GetArg(argIndex int) interface{} {
	switch argIndex {
	default:
		panic("arg index out of range")
	}
}

func (mc *TPWrapSkippedCall) SetArg(argIndex int, arg interface{}) {
	switch argIndex {
	default:
		panic("arg index out of range")
	}
}

func (mc *TPWrapSkippedCall) GetResult(resultIndex int) interface{} {
	switch resultIndex {
	case 0:
		return mc.Result0
	default:
		panic("result index out of range")
	}
}

func (mc *TPWrapSkippedCall) SetResult(resultIndex int, result interface{}) {
	switch resultIndex {
	case 0:
		mc.Result0 = result.(bool)
	default:
		panic("result index out of range")
	}
}

func (mc *TPWrapSkippedCall) MethodName() string   { return "Skipped" }
func (mc *TPWrapSkippedCall) MethodIndex() int     { return TPWrapSkipped }
func (mc *TPWrapSkippedCall) NumberOfArgs() int    { return 0 }
func (mc *TPWrapSkippedCall) NumberOfResults() int { return 1 }

func (mc *TPWrapSkippedCall) getNextInterceptor() (proxyz.MethodCallInterceptor, bool) {
	if i := mc.nextInterceptorIndex; i < len(mc.interceptors) {
		mc.nextInterceptorIndex++
		return mc.interceptors[i], true
	}

	return nil, false
}

func (p *TPWrap) Skipped() bool {
	methodCallInterceptors := p.XxxGetMethodCallInterceptors(TPWrapSkipped)

	if len(methodCallInterceptors) == 0 {
		return p.TB.Skipped()
	}

	methodCall := TPWrapSkippedCall{
		callee:       p.TB,
		interceptors: methodCallInterceptors,
	}

	methodCall.Forward()
	return methodCall.Result0
}

func (p *TPWrap) XxxNumberOfMethods() int { return 16 }
