// Code generated by proxyz. DO NOT EDIT.
package main

import (
	context "context"
	proxyz "github.com/roy2220/proxyz"
	net "net"
)

type ServerWrap struct {
	proxyz.XxxProxyBase
	*Server
}

var _ = (proxyz.Proxy)((*ServerWrap)(nil))

func NewServerWrap(underlying *Server) *ServerWrap {
	return &ServerWrap{
		Server: underlying,
	}
}

const ServerWrapClose = 0

type ServerWrapCloseCall struct {
	Result0 error

	callee               *Server
	interceptors         []proxyz.MethodCallInterceptor
	nextInterceptorIndex int
}

var _ = (proxyz.MethodCall)((*ServerWrapCloseCall)(nil))

func (mc *ServerWrapCloseCall) Forward() {
	if interceptor, ok := mc.getNextInterceptor(); ok {
		interceptor(mc)
		return
	}

	mc.Result0 = mc.callee.Close()
}

func (mc *ServerWrapCloseCall) GetArg(argIndex int) interface{} {
	switch argIndex {
	default:
		panic("arg index out of range")
	}
}

func (mc *ServerWrapCloseCall) SetArg(argIndex int, arg interface{}) {
	switch argIndex {
	default:
		panic("arg index out of range")
	}
}

func (mc *ServerWrapCloseCall) GetResult(resultIndex int) interface{} {
	switch resultIndex {
	case 0:
		return mc.Result0
	default:
		panic("result index out of range")
	}
}

func (mc *ServerWrapCloseCall) SetResult(resultIndex int, result interface{}) {
	switch resultIndex {
	case 0:
		mc.Result0 = result.(error)
	default:
		panic("result index out of range")
	}
}

func (mc *ServerWrapCloseCall) MethodName() string   { return "Close" }
func (mc *ServerWrapCloseCall) MethodIndex() int     { return ServerWrapClose }
func (mc *ServerWrapCloseCall) NumberOfArgs() int    { return 0 }
func (mc *ServerWrapCloseCall) NumberOfResults() int { return 1 }

func (mc *ServerWrapCloseCall) getNextInterceptor() (proxyz.MethodCallInterceptor, bool) {
	if i := mc.nextInterceptorIndex; i < len(mc.interceptors) {
		mc.nextInterceptorIndex++
		return mc.interceptors[i], true
	}

	return nil, false
}

func (p *ServerWrap) Close() error {
	methodCallInterceptors := p.XxxGetMethodCallInterceptors(ServerWrapClose)

	if len(methodCallInterceptors) == 0 {
		return p.Server.Close()
	}

	methodCall := ServerWrapCloseCall{
		callee:       p.Server,
		interceptors: methodCallInterceptors,
	}

	methodCall.Forward()
	return methodCall.Result0
}

const ServerWrapListenAndServe = 1

type ServerWrapListenAndServeCall struct {
	Result0 error

	callee               *Server
	interceptors         []proxyz.MethodCallInterceptor
	nextInterceptorIndex int
}

var _ = (proxyz.MethodCall)((*ServerWrapListenAndServeCall)(nil))

func (mc *ServerWrapListenAndServeCall) Forward() {
	if interceptor, ok := mc.getNextInterceptor(); ok {
		interceptor(mc)
		return
	}

	mc.Result0 = mc.callee.ListenAndServe()
}

func (mc *ServerWrapListenAndServeCall) GetArg(argIndex int) interface{} {
	switch argIndex {
	default:
		panic("arg index out of range")
	}
}

func (mc *ServerWrapListenAndServeCall) SetArg(argIndex int, arg interface{}) {
	switch argIndex {
	default:
		panic("arg index out of range")
	}
}

func (mc *ServerWrapListenAndServeCall) GetResult(resultIndex int) interface{} {
	switch resultIndex {
	case 0:
		return mc.Result0
	default:
		panic("result index out of range")
	}
}

func (mc *ServerWrapListenAndServeCall) SetResult(resultIndex int, result interface{}) {
	switch resultIndex {
	case 0:
		mc.Result0 = result.(error)
	default:
		panic("result index out of range")
	}
}

func (mc *ServerWrapListenAndServeCall) MethodName() string   { return "ListenAndServe" }
func (mc *ServerWrapListenAndServeCall) MethodIndex() int     { return ServerWrapListenAndServe }
func (mc *ServerWrapListenAndServeCall) NumberOfArgs() int    { return 0 }
func (mc *ServerWrapListenAndServeCall) NumberOfResults() int { return 1 }

func (mc *ServerWrapListenAndServeCall) getNextInterceptor() (proxyz.MethodCallInterceptor, bool) {
	if i := mc.nextInterceptorIndex; i < len(mc.interceptors) {
		mc.nextInterceptorIndex++
		return mc.interceptors[i], true
	}

	return nil, false
}

func (p *ServerWrap) ListenAndServe() error {
	methodCallInterceptors := p.XxxGetMethodCallInterceptors(ServerWrapListenAndServe)

	if len(methodCallInterceptors) == 0 {
		return p.Server.ListenAndServe()
	}

	methodCall := ServerWrapListenAndServeCall{
		callee:       p.Server,
		interceptors: methodCallInterceptors,
	}

	methodCall.Forward()
	return methodCall.Result0
}

const ServerWrapListenAndServeTLS = 2

type ServerWrapListenAndServeTLSCall struct {
	Arg0    string
	Arg1    string
	Result0 error

	callee               *Server
	interceptors         []proxyz.MethodCallInterceptor
	nextInterceptorIndex int
}

var _ = (proxyz.MethodCall)((*ServerWrapListenAndServeTLSCall)(nil))

func (mc *ServerWrapListenAndServeTLSCall) Forward() {
	if interceptor, ok := mc.getNextInterceptor(); ok {
		interceptor(mc)
		return
	}

	mc.Result0 = mc.callee.ListenAndServeTLS(mc.Arg0, mc.Arg1)
}

func (mc *ServerWrapListenAndServeTLSCall) GetArg(argIndex int) interface{} {
	switch argIndex {
	case 0:
		return mc.Arg0
	case 1:
		return mc.Arg1
	default:
		panic("arg index out of range")
	}
}

func (mc *ServerWrapListenAndServeTLSCall) SetArg(argIndex int, arg interface{}) {
	switch argIndex {
	case 0:
		mc.Arg0 = arg.(string)
	case 1:
		mc.Arg1 = arg.(string)
	default:
		panic("arg index out of range")
	}
}

func (mc *ServerWrapListenAndServeTLSCall) GetResult(resultIndex int) interface{} {
	switch resultIndex {
	case 0:
		return mc.Result0
	default:
		panic("result index out of range")
	}
}

func (mc *ServerWrapListenAndServeTLSCall) SetResult(resultIndex int, result interface{}) {
	switch resultIndex {
	case 0:
		mc.Result0 = result.(error)
	default:
		panic("result index out of range")
	}
}

func (mc *ServerWrapListenAndServeTLSCall) MethodName() string   { return "ListenAndServeTLS" }
func (mc *ServerWrapListenAndServeTLSCall) MethodIndex() int     { return ServerWrapListenAndServeTLS }
func (mc *ServerWrapListenAndServeTLSCall) NumberOfArgs() int    { return 2 }
func (mc *ServerWrapListenAndServeTLSCall) NumberOfResults() int { return 1 }

func (mc *ServerWrapListenAndServeTLSCall) getNextInterceptor() (proxyz.MethodCallInterceptor, bool) {
	if i := mc.nextInterceptorIndex; i < len(mc.interceptors) {
		mc.nextInterceptorIndex++
		return mc.interceptors[i], true
	}

	return nil, false
}

func (p *ServerWrap) ListenAndServeTLS(_certFile_ string, _keyFile_ string) error {
	methodCallInterceptors := p.XxxGetMethodCallInterceptors(ServerWrapListenAndServeTLS)

	if len(methodCallInterceptors) == 0 {
		return p.Server.ListenAndServeTLS(_certFile_, _keyFile_)
	}

	methodCall := ServerWrapListenAndServeTLSCall{
		Arg0: _certFile_,
		Arg1: _keyFile_,

		callee:       p.Server,
		interceptors: methodCallInterceptors,
	}

	methodCall.Forward()
	return methodCall.Result0
}

const ServerWrapRegisterOnShutdown = 3

type ServerWrapRegisterOnShutdownCall struct {
	Arg0 func()

	callee               *Server
	interceptors         []proxyz.MethodCallInterceptor
	nextInterceptorIndex int
}

var _ = (proxyz.MethodCall)((*ServerWrapRegisterOnShutdownCall)(nil))

func (mc *ServerWrapRegisterOnShutdownCall) Forward() {
	if interceptor, ok := mc.getNextInterceptor(); ok {
		interceptor(mc)
		return
	}

	mc.callee.RegisterOnShutdown(mc.Arg0)
}

func (mc *ServerWrapRegisterOnShutdownCall) GetArg(argIndex int) interface{} {
	switch argIndex {
	case 0:
		return mc.Arg0
	default:
		panic("arg index out of range")
	}
}

func (mc *ServerWrapRegisterOnShutdownCall) SetArg(argIndex int, arg interface{}) {
	switch argIndex {
	case 0:
		mc.Arg0 = arg.(func())
	default:
		panic("arg index out of range")
	}
}

func (mc *ServerWrapRegisterOnShutdownCall) GetResult(resultIndex int) interface{} {
	switch resultIndex {
	default:
		panic("result index out of range")
	}
}

func (mc *ServerWrapRegisterOnShutdownCall) SetResult(resultIndex int, result interface{}) {
	switch resultIndex {
	default:
		panic("result index out of range")
	}
}

func (mc *ServerWrapRegisterOnShutdownCall) MethodName() string   { return "RegisterOnShutdown" }
func (mc *ServerWrapRegisterOnShutdownCall) MethodIndex() int     { return ServerWrapRegisterOnShutdown }
func (mc *ServerWrapRegisterOnShutdownCall) NumberOfArgs() int    { return 1 }
func (mc *ServerWrapRegisterOnShutdownCall) NumberOfResults() int { return 0 }

func (mc *ServerWrapRegisterOnShutdownCall) getNextInterceptor() (proxyz.MethodCallInterceptor, bool) {
	if i := mc.nextInterceptorIndex; i < len(mc.interceptors) {
		mc.nextInterceptorIndex++
		return mc.interceptors[i], true
	}

	return nil, false
}

func (p *ServerWrap) RegisterOnShutdown(_f_ func()) {
	methodCallInterceptors := p.XxxGetMethodCallInterceptors(ServerWrapRegisterOnShutdown)

	if len(methodCallInterceptors) == 0 {
		p.Server.RegisterOnShutdown(_f_)
	}

	methodCall := ServerWrapRegisterOnShutdownCall{
		Arg0: _f_,

		callee:       p.Server,
		interceptors: methodCallInterceptors,
	}

	methodCall.Forward()
}

const ServerWrapServe = 4

type ServerWrapServeCall struct {
	Arg0    net.Listener
	Result0 error

	callee               *Server
	interceptors         []proxyz.MethodCallInterceptor
	nextInterceptorIndex int
}

var _ = (proxyz.MethodCall)((*ServerWrapServeCall)(nil))

func (mc *ServerWrapServeCall) Forward() {
	if interceptor, ok := mc.getNextInterceptor(); ok {
		interceptor(mc)
		return
	}

	mc.Result0 = mc.callee.Serve(mc.Arg0)
}

func (mc *ServerWrapServeCall) GetArg(argIndex int) interface{} {
	switch argIndex {
	case 0:
		return mc.Arg0
	default:
		panic("arg index out of range")
	}
}

func (mc *ServerWrapServeCall) SetArg(argIndex int, arg interface{}) {
	switch argIndex {
	case 0:
		mc.Arg0 = arg.(net.Listener)
	default:
		panic("arg index out of range")
	}
}

func (mc *ServerWrapServeCall) GetResult(resultIndex int) interface{} {
	switch resultIndex {
	case 0:
		return mc.Result0
	default:
		panic("result index out of range")
	}
}

func (mc *ServerWrapServeCall) SetResult(resultIndex int, result interface{}) {
	switch resultIndex {
	case 0:
		mc.Result0 = result.(error)
	default:
		panic("result index out of range")
	}
}

func (mc *ServerWrapServeCall) MethodName() string   { return "Serve" }
func (mc *ServerWrapServeCall) MethodIndex() int     { return ServerWrapServe }
func (mc *ServerWrapServeCall) NumberOfArgs() int    { return 1 }
func (mc *ServerWrapServeCall) NumberOfResults() int { return 1 }

func (mc *ServerWrapServeCall) getNextInterceptor() (proxyz.MethodCallInterceptor, bool) {
	if i := mc.nextInterceptorIndex; i < len(mc.interceptors) {
		mc.nextInterceptorIndex++
		return mc.interceptors[i], true
	}

	return nil, false
}

func (p *ServerWrap) Serve(_l_ net.Listener) error {
	methodCallInterceptors := p.XxxGetMethodCallInterceptors(ServerWrapServe)

	if len(methodCallInterceptors) == 0 {
		return p.Server.Serve(_l_)
	}

	methodCall := ServerWrapServeCall{
		Arg0: _l_,

		callee:       p.Server,
		interceptors: methodCallInterceptors,
	}

	methodCall.Forward()
	return methodCall.Result0
}

const ServerWrapServeTLS = 5

type ServerWrapServeTLSCall struct {
	Arg0    net.Listener
	Arg1    string
	Arg2    string
	Result0 error

	callee               *Server
	interceptors         []proxyz.MethodCallInterceptor
	nextInterceptorIndex int
}

var _ = (proxyz.MethodCall)((*ServerWrapServeTLSCall)(nil))

func (mc *ServerWrapServeTLSCall) Forward() {
	if interceptor, ok := mc.getNextInterceptor(); ok {
		interceptor(mc)
		return
	}

	mc.Result0 = mc.callee.ServeTLS(mc.Arg0, mc.Arg1, mc.Arg2)
}

func (mc *ServerWrapServeTLSCall) GetArg(argIndex int) interface{} {
	switch argIndex {
	case 0:
		return mc.Arg0
	case 1:
		return mc.Arg1
	case 2:
		return mc.Arg2
	default:
		panic("arg index out of range")
	}
}

func (mc *ServerWrapServeTLSCall) SetArg(argIndex int, arg interface{}) {
	switch argIndex {
	case 0:
		mc.Arg0 = arg.(net.Listener)
	case 1:
		mc.Arg1 = arg.(string)
	case 2:
		mc.Arg2 = arg.(string)
	default:
		panic("arg index out of range")
	}
}

func (mc *ServerWrapServeTLSCall) GetResult(resultIndex int) interface{} {
	switch resultIndex {
	case 0:
		return mc.Result0
	default:
		panic("result index out of range")
	}
}

func (mc *ServerWrapServeTLSCall) SetResult(resultIndex int, result interface{}) {
	switch resultIndex {
	case 0:
		mc.Result0 = result.(error)
	default:
		panic("result index out of range")
	}
}

func (mc *ServerWrapServeTLSCall) MethodName() string   { return "ServeTLS" }
func (mc *ServerWrapServeTLSCall) MethodIndex() int     { return ServerWrapServeTLS }
func (mc *ServerWrapServeTLSCall) NumberOfArgs() int    { return 3 }
func (mc *ServerWrapServeTLSCall) NumberOfResults() int { return 1 }

func (mc *ServerWrapServeTLSCall) getNextInterceptor() (proxyz.MethodCallInterceptor, bool) {
	if i := mc.nextInterceptorIndex; i < len(mc.interceptors) {
		mc.nextInterceptorIndex++
		return mc.interceptors[i], true
	}

	return nil, false
}

func (p *ServerWrap) ServeTLS(_l_ net.Listener, _certFile_ string, _keyFile_ string) error {
	methodCallInterceptors := p.XxxGetMethodCallInterceptors(ServerWrapServeTLS)

	if len(methodCallInterceptors) == 0 {
		return p.Server.ServeTLS(_l_, _certFile_, _keyFile_)
	}

	methodCall := ServerWrapServeTLSCall{
		Arg0: _l_,
		Arg1: _certFile_,
		Arg2: _keyFile_,

		callee:       p.Server,
		interceptors: methodCallInterceptors,
	}

	methodCall.Forward()
	return methodCall.Result0
}

const ServerWrapSetKeepAlivesEnabled = 6

type ServerWrapSetKeepAlivesEnabledCall struct {
	Arg0 bool

	callee               *Server
	interceptors         []proxyz.MethodCallInterceptor
	nextInterceptorIndex int
}

var _ = (proxyz.MethodCall)((*ServerWrapSetKeepAlivesEnabledCall)(nil))

func (mc *ServerWrapSetKeepAlivesEnabledCall) Forward() {
	if interceptor, ok := mc.getNextInterceptor(); ok {
		interceptor(mc)
		return
	}

	mc.callee.SetKeepAlivesEnabled(mc.Arg0)
}

func (mc *ServerWrapSetKeepAlivesEnabledCall) GetArg(argIndex int) interface{} {
	switch argIndex {
	case 0:
		return mc.Arg0
	default:
		panic("arg index out of range")
	}
}

func (mc *ServerWrapSetKeepAlivesEnabledCall) SetArg(argIndex int, arg interface{}) {
	switch argIndex {
	case 0:
		mc.Arg0 = arg.(bool)
	default:
		panic("arg index out of range")
	}
}

func (mc *ServerWrapSetKeepAlivesEnabledCall) GetResult(resultIndex int) interface{} {
	switch resultIndex {
	default:
		panic("result index out of range")
	}
}

func (mc *ServerWrapSetKeepAlivesEnabledCall) SetResult(resultIndex int, result interface{}) {
	switch resultIndex {
	default:
		panic("result index out of range")
	}
}

func (mc *ServerWrapSetKeepAlivesEnabledCall) MethodName() string { return "SetKeepAlivesEnabled" }
func (mc *ServerWrapSetKeepAlivesEnabledCall) MethodIndex() int {
	return ServerWrapSetKeepAlivesEnabled
}
func (mc *ServerWrapSetKeepAlivesEnabledCall) NumberOfArgs() int    { return 1 }
func (mc *ServerWrapSetKeepAlivesEnabledCall) NumberOfResults() int { return 0 }

func (mc *ServerWrapSetKeepAlivesEnabledCall) getNextInterceptor() (proxyz.MethodCallInterceptor, bool) {
	if i := mc.nextInterceptorIndex; i < len(mc.interceptors) {
		mc.nextInterceptorIndex++
		return mc.interceptors[i], true
	}

	return nil, false
}

func (p *ServerWrap) SetKeepAlivesEnabled(_v_ bool) {
	methodCallInterceptors := p.XxxGetMethodCallInterceptors(ServerWrapSetKeepAlivesEnabled)

	if len(methodCallInterceptors) == 0 {
		p.Server.SetKeepAlivesEnabled(_v_)
	}

	methodCall := ServerWrapSetKeepAlivesEnabledCall{
		Arg0: _v_,

		callee:       p.Server,
		interceptors: methodCallInterceptors,
	}

	methodCall.Forward()
}

const ServerWrapShutdown = 7

type ServerWrapShutdownCall struct {
	Arg0    context.Context
	Result0 error

	callee               *Server
	interceptors         []proxyz.MethodCallInterceptor
	nextInterceptorIndex int
}

var _ = (proxyz.MethodCall)((*ServerWrapShutdownCall)(nil))

func (mc *ServerWrapShutdownCall) Forward() {
	if interceptor, ok := mc.getNextInterceptor(); ok {
		interceptor(mc)
		return
	}

	mc.Result0 = mc.callee.Shutdown(mc.Arg0)
}

func (mc *ServerWrapShutdownCall) GetArg(argIndex int) interface{} {
	switch argIndex {
	case 0:
		return mc.Arg0
	default:
		panic("arg index out of range")
	}
}

func (mc *ServerWrapShutdownCall) SetArg(argIndex int, arg interface{}) {
	switch argIndex {
	case 0:
		mc.Arg0 = arg.(context.Context)
	default:
		panic("arg index out of range")
	}
}

func (mc *ServerWrapShutdownCall) GetResult(resultIndex int) interface{} {
	switch resultIndex {
	case 0:
		return mc.Result0
	default:
		panic("result index out of range")
	}
}

func (mc *ServerWrapShutdownCall) SetResult(resultIndex int, result interface{}) {
	switch resultIndex {
	case 0:
		mc.Result0 = result.(error)
	default:
		panic("result index out of range")
	}
}

func (mc *ServerWrapShutdownCall) MethodName() string   { return "Shutdown" }
func (mc *ServerWrapShutdownCall) MethodIndex() int     { return ServerWrapShutdown }
func (mc *ServerWrapShutdownCall) NumberOfArgs() int    { return 1 }
func (mc *ServerWrapShutdownCall) NumberOfResults() int { return 1 }

func (mc *ServerWrapShutdownCall) getNextInterceptor() (proxyz.MethodCallInterceptor, bool) {
	if i := mc.nextInterceptorIndex; i < len(mc.interceptors) {
		mc.nextInterceptorIndex++
		return mc.interceptors[i], true
	}

	return nil, false
}

func (p *ServerWrap) Shutdown(_ctx_ context.Context) error {
	methodCallInterceptors := p.XxxGetMethodCallInterceptors(ServerWrapShutdown)

	if len(methodCallInterceptors) == 0 {
		return p.Server.Shutdown(_ctx_)
	}

	methodCall := ServerWrapShutdownCall{
		Arg0: _ctx_,

		callee:       p.Server,
		interceptors: methodCallInterceptors,
	}

	methodCall.Forward()
	return methodCall.Result0
}

func (p *ServerWrap) XxxNumberOfMethods() int { return 8 }
