// Code generated by proxyz. DO NOT EDIT.
package main

import (
	proxyz "github.com/roy2220/proxyz"
	os "os"
)

type FileWrap struct {
	proxyz.XxxProxyBase
	File
}

var _ = (proxyz.Proxy)((*FileWrap)(nil))

func NewFileWrap(underlying File) *FileWrap {
	return &FileWrap{
		File: underlying,
	}
}

const FileWrapClose = 0

type FileWrapCloseCall struct {
	Result0 error

	callee               File
	interceptors         []proxyz.MethodCallInterceptor
	nextInterceptorIndex int
}

var _ = (proxyz.MethodCall)((*FileWrapCloseCall)(nil))

func (mc *FileWrapCloseCall) Forward() {
	if interceptor, ok := mc.getNextInterceptor(); ok {
		interceptor(mc)
		return
	}

	mc.Result0 = mc.callee.Close()
}

func (mc *FileWrapCloseCall) GetArg(argIndex int) interface{} {
	switch argIndex {
	default:
		panic("arg index out of range")
	}
}

func (mc *FileWrapCloseCall) SetArg(argIndex int, arg interface{}) {
	switch argIndex {
	default:
		panic("arg index out of range")
	}
}

func (mc *FileWrapCloseCall) GetResult(resultIndex int) interface{} {
	switch resultIndex {
	case 0:
		return mc.Result0
	default:
		panic("result index out of range")
	}
}

func (mc *FileWrapCloseCall) SetResult(resultIndex int, result interface{}) {
	switch resultIndex {
	case 0:
		mc.Result0 = result.(error)
	default:
		panic("result index out of range")
	}
}

func (mc *FileWrapCloseCall) MethodName() string   { return "Close" }
func (mc *FileWrapCloseCall) MethodIndex() int     { return FileWrapClose }
func (mc *FileWrapCloseCall) NumberOfArgs() int    { return 0 }
func (mc *FileWrapCloseCall) NumberOfResults() int { return 1 }

func (mc *FileWrapCloseCall) getNextInterceptor() (proxyz.MethodCallInterceptor, bool) {
	if i := mc.nextInterceptorIndex; i < len(mc.interceptors) {
		mc.nextInterceptorIndex++
		return mc.interceptors[i], true
	}

	return nil, false
}

func (p *FileWrap) Close() error {
	methodCallInterceptors := p.XxxGetMethodCallInterceptors(FileWrapClose)

	if len(methodCallInterceptors) == 0 {
		return p.File.Close()
	}

	methodCall := FileWrapCloseCall{
		callee:       p.File,
		interceptors: methodCallInterceptors,
	}

	methodCall.Forward()
	return methodCall.Result0
}

const FileWrapRead = 1

type FileWrapReadCall struct {
	Arg0    []byte
	Result0 int
	Result1 error

	callee               File
	interceptors         []proxyz.MethodCallInterceptor
	nextInterceptorIndex int
}

var _ = (proxyz.MethodCall)((*FileWrapReadCall)(nil))

func (mc *FileWrapReadCall) Forward() {
	if interceptor, ok := mc.getNextInterceptor(); ok {
		interceptor(mc)
		return
	}

	mc.Result0, mc.Result1 = mc.callee.Read(mc.Arg0)
}

func (mc *FileWrapReadCall) GetArg(argIndex int) interface{} {
	switch argIndex {
	case 0:
		return mc.Arg0
	default:
		panic("arg index out of range")
	}
}

func (mc *FileWrapReadCall) SetArg(argIndex int, arg interface{}) {
	switch argIndex {
	case 0:
		mc.Arg0 = arg.([]byte)
	default:
		panic("arg index out of range")
	}
}

func (mc *FileWrapReadCall) GetResult(resultIndex int) interface{} {
	switch resultIndex {
	case 0:
		return mc.Result0
	case 1:
		return mc.Result1
	default:
		panic("result index out of range")
	}
}

func (mc *FileWrapReadCall) SetResult(resultIndex int, result interface{}) {
	switch resultIndex {
	case 0:
		mc.Result0 = result.(int)
	case 1:
		mc.Result1 = result.(error)
	default:
		panic("result index out of range")
	}
}

func (mc *FileWrapReadCall) MethodName() string   { return "Read" }
func (mc *FileWrapReadCall) MethodIndex() int     { return FileWrapRead }
func (mc *FileWrapReadCall) NumberOfArgs() int    { return 1 }
func (mc *FileWrapReadCall) NumberOfResults() int { return 2 }

func (mc *FileWrapReadCall) getNextInterceptor() (proxyz.MethodCallInterceptor, bool) {
	if i := mc.nextInterceptorIndex; i < len(mc.interceptors) {
		mc.nextInterceptorIndex++
		return mc.interceptors[i], true
	}

	return nil, false
}

func (p *FileWrap) Read(_p_ []byte) (int, error) {
	methodCallInterceptors := p.XxxGetMethodCallInterceptors(FileWrapRead)

	if len(methodCallInterceptors) == 0 {
		return p.File.Read(_p_)
	}

	methodCall := FileWrapReadCall{
		Arg0: _p_,

		callee:       p.File,
		interceptors: methodCallInterceptors,
	}

	methodCall.Forward()
	return methodCall.Result0, methodCall.Result1
}

const FileWrapReaddir = 2

type FileWrapReaddirCall struct {
	Arg0    int
	Result0 []os.FileInfo
	Result1 error

	callee               File
	interceptors         []proxyz.MethodCallInterceptor
	nextInterceptorIndex int
}

var _ = (proxyz.MethodCall)((*FileWrapReaddirCall)(nil))

func (mc *FileWrapReaddirCall) Forward() {
	if interceptor, ok := mc.getNextInterceptor(); ok {
		interceptor(mc)
		return
	}

	mc.Result0, mc.Result1 = mc.callee.Readdir(mc.Arg0)
}

func (mc *FileWrapReaddirCall) GetArg(argIndex int) interface{} {
	switch argIndex {
	case 0:
		return mc.Arg0
	default:
		panic("arg index out of range")
	}
}

func (mc *FileWrapReaddirCall) SetArg(argIndex int, arg interface{}) {
	switch argIndex {
	case 0:
		mc.Arg0 = arg.(int)
	default:
		panic("arg index out of range")
	}
}

func (mc *FileWrapReaddirCall) GetResult(resultIndex int) interface{} {
	switch resultIndex {
	case 0:
		return mc.Result0
	case 1:
		return mc.Result1
	default:
		panic("result index out of range")
	}
}

func (mc *FileWrapReaddirCall) SetResult(resultIndex int, result interface{}) {
	switch resultIndex {
	case 0:
		mc.Result0 = result.([]os.FileInfo)
	case 1:
		mc.Result1 = result.(error)
	default:
		panic("result index out of range")
	}
}

func (mc *FileWrapReaddirCall) MethodName() string   { return "Readdir" }
func (mc *FileWrapReaddirCall) MethodIndex() int     { return FileWrapReaddir }
func (mc *FileWrapReaddirCall) NumberOfArgs() int    { return 1 }
func (mc *FileWrapReaddirCall) NumberOfResults() int { return 2 }

func (mc *FileWrapReaddirCall) getNextInterceptor() (proxyz.MethodCallInterceptor, bool) {
	if i := mc.nextInterceptorIndex; i < len(mc.interceptors) {
		mc.nextInterceptorIndex++
		return mc.interceptors[i], true
	}

	return nil, false
}

func (p *FileWrap) Readdir(_count_ int) ([]os.FileInfo, error) {
	methodCallInterceptors := p.XxxGetMethodCallInterceptors(FileWrapReaddir)

	if len(methodCallInterceptors) == 0 {
		return p.File.Readdir(_count_)
	}

	methodCall := FileWrapReaddirCall{
		Arg0: _count_,

		callee:       p.File,
		interceptors: methodCallInterceptors,
	}

	methodCall.Forward()
	return methodCall.Result0, methodCall.Result1
}

const FileWrapSeek = 3

type FileWrapSeekCall struct {
	Arg0    int64
	Arg1    int
	Result0 int64
	Result1 error

	callee               File
	interceptors         []proxyz.MethodCallInterceptor
	nextInterceptorIndex int
}

var _ = (proxyz.MethodCall)((*FileWrapSeekCall)(nil))

func (mc *FileWrapSeekCall) Forward() {
	if interceptor, ok := mc.getNextInterceptor(); ok {
		interceptor(mc)
		return
	}

	mc.Result0, mc.Result1 = mc.callee.Seek(mc.Arg0, mc.Arg1)
}

func (mc *FileWrapSeekCall) GetArg(argIndex int) interface{} {
	switch argIndex {
	case 0:
		return mc.Arg0
	case 1:
		return mc.Arg1
	default:
		panic("arg index out of range")
	}
}

func (mc *FileWrapSeekCall) SetArg(argIndex int, arg interface{}) {
	switch argIndex {
	case 0:
		mc.Arg0 = arg.(int64)
	case 1:
		mc.Arg1 = arg.(int)
	default:
		panic("arg index out of range")
	}
}

func (mc *FileWrapSeekCall) GetResult(resultIndex int) interface{} {
	switch resultIndex {
	case 0:
		return mc.Result0
	case 1:
		return mc.Result1
	default:
		panic("result index out of range")
	}
}

func (mc *FileWrapSeekCall) SetResult(resultIndex int, result interface{}) {
	switch resultIndex {
	case 0:
		mc.Result0 = result.(int64)
	case 1:
		mc.Result1 = result.(error)
	default:
		panic("result index out of range")
	}
}

func (mc *FileWrapSeekCall) MethodName() string   { return "Seek" }
func (mc *FileWrapSeekCall) MethodIndex() int     { return FileWrapSeek }
func (mc *FileWrapSeekCall) NumberOfArgs() int    { return 2 }
func (mc *FileWrapSeekCall) NumberOfResults() int { return 2 }

func (mc *FileWrapSeekCall) getNextInterceptor() (proxyz.MethodCallInterceptor, bool) {
	if i := mc.nextInterceptorIndex; i < len(mc.interceptors) {
		mc.nextInterceptorIndex++
		return mc.interceptors[i], true
	}

	return nil, false
}

func (p *FileWrap) Seek(_offset_ int64, _whence_ int) (int64, error) {
	methodCallInterceptors := p.XxxGetMethodCallInterceptors(FileWrapSeek)

	if len(methodCallInterceptors) == 0 {
		return p.File.Seek(_offset_, _whence_)
	}

	methodCall := FileWrapSeekCall{
		Arg0: _offset_,
		Arg1: _whence_,

		callee:       p.File,
		interceptors: methodCallInterceptors,
	}

	methodCall.Forward()
	return methodCall.Result0, methodCall.Result1
}

const FileWrapStat = 4

type FileWrapStatCall struct {
	Result0 os.FileInfo
	Result1 error

	callee               File
	interceptors         []proxyz.MethodCallInterceptor
	nextInterceptorIndex int
}

var _ = (proxyz.MethodCall)((*FileWrapStatCall)(nil))

func (mc *FileWrapStatCall) Forward() {
	if interceptor, ok := mc.getNextInterceptor(); ok {
		interceptor(mc)
		return
	}

	mc.Result0, mc.Result1 = mc.callee.Stat()
}

func (mc *FileWrapStatCall) GetArg(argIndex int) interface{} {
	switch argIndex {
	default:
		panic("arg index out of range")
	}
}

func (mc *FileWrapStatCall) SetArg(argIndex int, arg interface{}) {
	switch argIndex {
	default:
		panic("arg index out of range")
	}
}

func (mc *FileWrapStatCall) GetResult(resultIndex int) interface{} {
	switch resultIndex {
	case 0:
		return mc.Result0
	case 1:
		return mc.Result1
	default:
		panic("result index out of range")
	}
}

func (mc *FileWrapStatCall) SetResult(resultIndex int, result interface{}) {
	switch resultIndex {
	case 0:
		mc.Result0 = result.(os.FileInfo)
	case 1:
		mc.Result1 = result.(error)
	default:
		panic("result index out of range")
	}
}

func (mc *FileWrapStatCall) MethodName() string   { return "Stat" }
func (mc *FileWrapStatCall) MethodIndex() int     { return FileWrapStat }
func (mc *FileWrapStatCall) NumberOfArgs() int    { return 0 }
func (mc *FileWrapStatCall) NumberOfResults() int { return 2 }

func (mc *FileWrapStatCall) getNextInterceptor() (proxyz.MethodCallInterceptor, bool) {
	if i := mc.nextInterceptorIndex; i < len(mc.interceptors) {
		mc.nextInterceptorIndex++
		return mc.interceptors[i], true
	}

	return nil, false
}

func (p *FileWrap) Stat() (os.FileInfo, error) {
	methodCallInterceptors := p.XxxGetMethodCallInterceptors(FileWrapStat)

	if len(methodCallInterceptors) == 0 {
		return p.File.Stat()
	}

	methodCall := FileWrapStatCall{
		callee:       p.File,
		interceptors: methodCallInterceptors,
	}

	methodCall.Forward()
	return methodCall.Result0, methodCall.Result1
}

func (p *FileWrap) XxxNumberOfMethods() int { return 5 }
