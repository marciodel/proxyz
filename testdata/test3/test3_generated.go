// Code generated by proxyz. DO NOT EDIT.
package main

import (
	proxyz "github.com/roy2220/proxyz"
)

type CalcProxy struct {
	proxyz.XxxProxyBase
	*Calc
}

var _ = (proxyz.Proxy)((*CalcProxy)(nil))

func NewCalcProxy(underlying *Calc) *CalcProxy {
	return &CalcProxy{
		Calc: underlying,
	}
}

const CalcProxySum = 0

type CalcProxySumCall struct {
	Arg0    int
	Arg1    int
	Result0 string

	callee               *Calc
	interceptors         []proxyz.MethodCallInterceptor
	nextInterceptorIndex int
}

var _ = (proxyz.MethodCall)((*CalcProxySumCall)(nil))

func (mc *CalcProxySumCall) Forward() {
	if interceptor, ok := mc.getNextInterceptor(); ok {
		interceptor(mc)
		return
	}

	mc.Result0 = mc.callee.Sum(mc.Arg0, mc.Arg1)
}

func (mc *CalcProxySumCall) GetArg(argIndex int) interface{} {
	switch argIndex {
	case 0:
		return mc.Arg0
	case 1:
		return mc.Arg1
	default:
		panic("arg index out of range")
	}
}

func (mc *CalcProxySumCall) SetArg(argIndex int, arg interface{}) {
	switch argIndex {
	case 0:
		mc.Arg0 = arg.(int)
	case 1:
		mc.Arg1 = arg.(int)
	default:
		panic("arg index out of range")
	}
}

func (mc *CalcProxySumCall) GetResult(resultIndex int) interface{} {
	switch resultIndex {
	case 0:
		return mc.Result0
	default:
		panic("result index out of range")
	}
}

func (mc *CalcProxySumCall) SetResult(resultIndex int, result interface{}) {
	switch resultIndex {
	case 0:
		mc.Result0 = result.(string)
	default:
		panic("result index out of range")
	}
}

func (mc *CalcProxySumCall) MethodName() string   { return "Sum" }
func (mc *CalcProxySumCall) MethodIndex() int     { return CalcProxySum }
func (mc *CalcProxySumCall) NumberOfArgs() int    { return 2 }
func (mc *CalcProxySumCall) NumberOfResults() int { return 1 }

func (mc *CalcProxySumCall) getNextInterceptor() (proxyz.MethodCallInterceptor, bool) {
	if i := mc.nextInterceptorIndex; i < len(mc.interceptors) {
		mc.nextInterceptorIndex++
		return mc.interceptors[i], true
	}

	return nil, false
}

func (p *CalcProxy) Sum(_a_ int, _b_ int) string {
	methodCallInterceptors := p.XxxGetMethodCallInterceptors(CalcProxySum)

	if len(methodCallInterceptors) == 0 {
		return p.Calc.Sum(_a_, _b_)
	}

	methodCall := CalcProxySumCall{
		Arg0: _a_,
		Arg1: _b_,

		callee:       p.Calc,
		interceptors: methodCallInterceptors,
	}

	methodCall.Forward()
	return methodCall.Result0
}

func (p *CalcProxy) XxxNumberOfMethods() int { return 1 }
