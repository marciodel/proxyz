// Code generated by proxyz. DO NOT EDIT.
package main

import (
	context "context"
	proxyz "github.com/roy2220/proxyz"
	foo "github.com/roy2220/proxyz/testdata/foo"
)

type Test1AProxy struct {
	proxyz.XxxProxyBase
	*foo.Test1A
}

var _ = (proxyz.Proxy)((*Test1AProxy)(nil))

func NewTest1AProxy(underlying *foo.Test1A) *Test1AProxy {
	return &Test1AProxy{
		Test1A: underlying,
	}
}

const Test1AProxyA1 = 0

type Test1AProxyA1Call struct {
	callee               *foo.Test1A
	interceptors         []proxyz.MethodCallInterceptor
	nextInterceptorIndex int
}

var _ = (proxyz.MethodCall)((*Test1AProxyA1Call)(nil))

func (mc *Test1AProxyA1Call) Forward() {
	if interceptor, ok := mc.getNextInterceptor(); ok {
		interceptor(mc)
		return
	}

	mc.callee.A1()
}

func (mc *Test1AProxyA1Call) GetArg(argIndex int) interface{} {
	switch argIndex {
	default:
		panic("arg index out of range")
	}
}

func (mc *Test1AProxyA1Call) SetArg(argIndex int, arg interface{}) {
	switch argIndex {
	default:
		panic("arg index out of range")
	}
}

func (mc *Test1AProxyA1Call) GetResult(resultIndex int) interface{} {
	switch resultIndex {
	default:
		panic("result index out of range")
	}
}

func (mc *Test1AProxyA1Call) SetResult(resultIndex int, result interface{}) {
	switch resultIndex {
	default:
		panic("result index out of range")
	}
}

func (mc *Test1AProxyA1Call) MethodName() string   { return "A1" }
func (mc *Test1AProxyA1Call) MethodIndex() int     { return Test1AProxyA1 }
func (mc *Test1AProxyA1Call) NumberOfArgs() int    { return 0 }
func (mc *Test1AProxyA1Call) NumberOfResults() int { return 0 }

func (mc *Test1AProxyA1Call) getNextInterceptor() (proxyz.MethodCallInterceptor, bool) {
	if i := mc.nextInterceptorIndex; i < len(mc.interceptors) {
		mc.nextInterceptorIndex++
		return mc.interceptors[i], true
	}

	return nil, false
}

func (p *Test1AProxy) A1() {
	methodCallInterceptors := p.XxxGetMethodCallInterceptors(Test1AProxyA1)

	if len(methodCallInterceptors) == 0 {
		p.Test1A.A1()
	}

	methodCall := Test1AProxyA1Call{
		callee:       p.Test1A,
		interceptors: methodCallInterceptors,
	}

	methodCall.Forward()
}

const Test1AProxyA2 = 1

type Test1AProxyA2Call struct {
	callee               *foo.Test1A
	interceptors         []proxyz.MethodCallInterceptor
	nextInterceptorIndex int
}

var _ = (proxyz.MethodCall)((*Test1AProxyA2Call)(nil))

func (mc *Test1AProxyA2Call) Forward() {
	if interceptor, ok := mc.getNextInterceptor(); ok {
		interceptor(mc)
		return
	}

	mc.callee.A2()
}

func (mc *Test1AProxyA2Call) GetArg(argIndex int) interface{} {
	switch argIndex {
	default:
		panic("arg index out of range")
	}
}

func (mc *Test1AProxyA2Call) SetArg(argIndex int, arg interface{}) {
	switch argIndex {
	default:
		panic("arg index out of range")
	}
}

func (mc *Test1AProxyA2Call) GetResult(resultIndex int) interface{} {
	switch resultIndex {
	default:
		panic("result index out of range")
	}
}

func (mc *Test1AProxyA2Call) SetResult(resultIndex int, result interface{}) {
	switch resultIndex {
	default:
		panic("result index out of range")
	}
}

func (mc *Test1AProxyA2Call) MethodName() string   { return "A2" }
func (mc *Test1AProxyA2Call) MethodIndex() int     { return Test1AProxyA2 }
func (mc *Test1AProxyA2Call) NumberOfArgs() int    { return 0 }
func (mc *Test1AProxyA2Call) NumberOfResults() int { return 0 }

func (mc *Test1AProxyA2Call) getNextInterceptor() (proxyz.MethodCallInterceptor, bool) {
	if i := mc.nextInterceptorIndex; i < len(mc.interceptors) {
		mc.nextInterceptorIndex++
		return mc.interceptors[i], true
	}

	return nil, false
}

func (p *Test1AProxy) A2() {
	methodCallInterceptors := p.XxxGetMethodCallInterceptors(Test1AProxyA2)

	if len(methodCallInterceptors) == 0 {
		p.Test1A.A2()
	}

	methodCall := Test1AProxyA2Call{
		callee:       p.Test1A,
		interceptors: methodCallInterceptors,
	}

	methodCall.Forward()
}

const Test1AProxyC1 = 2

type Test1AProxyC1Call struct {
	Arg0    int
	Arg1    []struct{}
	Result0 int
	Result1 func() func(context.Context)

	callee               *foo.Test1A
	interceptors         []proxyz.MethodCallInterceptor
	nextInterceptorIndex int
}

var _ = (proxyz.MethodCall)((*Test1AProxyC1Call)(nil))

func (mc *Test1AProxyC1Call) Forward() {
	if interceptor, ok := mc.getNextInterceptor(); ok {
		interceptor(mc)
		return
	}

	mc.Result0, mc.Result1 = mc.callee.C1(mc.Arg0, mc.Arg1...)
}

func (mc *Test1AProxyC1Call) GetArg(argIndex int) interface{} {
	switch argIndex {
	case 0:
		return mc.Arg0
	case 1:
		return mc.Arg1
	default:
		panic("arg index out of range")
	}
}

func (mc *Test1AProxyC1Call) SetArg(argIndex int, arg interface{}) {
	switch argIndex {
	case 0:
		mc.Arg0 = arg.(int)
	case 1:
		mc.Arg1 = arg.([]struct{})
	default:
		panic("arg index out of range")
	}
}

func (mc *Test1AProxyC1Call) GetResult(resultIndex int) interface{} {
	switch resultIndex {
	case 0:
		return mc.Result0
	case 1:
		return mc.Result1
	default:
		panic("result index out of range")
	}
}

func (mc *Test1AProxyC1Call) SetResult(resultIndex int, result interface{}) {
	switch resultIndex {
	case 0:
		mc.Result0 = result.(int)
	case 1:
		mc.Result1 = result.(func() func(context.Context))
	default:
		panic("result index out of range")
	}
}

func (mc *Test1AProxyC1Call) MethodName() string   { return "C1" }
func (mc *Test1AProxyC1Call) MethodIndex() int     { return Test1AProxyC1 }
func (mc *Test1AProxyC1Call) NumberOfArgs() int    { return 2 }
func (mc *Test1AProxyC1Call) NumberOfResults() int { return 2 }

func (mc *Test1AProxyC1Call) getNextInterceptor() (proxyz.MethodCallInterceptor, bool) {
	if i := mc.nextInterceptorIndex; i < len(mc.interceptors) {
		mc.nextInterceptorIndex++
		return mc.interceptors[i], true
	}

	return nil, false
}

func (p *Test1AProxy) C1(arg0 int, arg1 ...struct{}) (int, func() func(context.Context)) {
	methodCallInterceptors := p.XxxGetMethodCallInterceptors(Test1AProxyC1)

	if len(methodCallInterceptors) == 0 {
		return p.Test1A.C1(arg0, arg1...)
	}

	methodCall := Test1AProxyC1Call{
		Arg0: arg0,
		Arg1: arg1,

		callee:       p.Test1A,
		interceptors: methodCallInterceptors,
	}

	methodCall.Forward()
	return methodCall.Result0, methodCall.Result1
}

const Test1AProxyC2 = 3

type Test1AProxyC2Call struct {
	Arg0    []string
	Arg1    string
	Result0 float64
	Result1 float64

	callee               *foo.Test1A
	interceptors         []proxyz.MethodCallInterceptor
	nextInterceptorIndex int
}

var _ = (proxyz.MethodCall)((*Test1AProxyC2Call)(nil))

func (mc *Test1AProxyC2Call) Forward() {
	if interceptor, ok := mc.getNextInterceptor(); ok {
		interceptor(mc)
		return
	}

	mc.Result0, mc.Result1 = mc.callee.C2(mc.Arg0, mc.Arg1)
}

func (mc *Test1AProxyC2Call) GetArg(argIndex int) interface{} {
	switch argIndex {
	case 0:
		return mc.Arg0
	case 1:
		return mc.Arg1
	default:
		panic("arg index out of range")
	}
}

func (mc *Test1AProxyC2Call) SetArg(argIndex int, arg interface{}) {
	switch argIndex {
	case 0:
		mc.Arg0 = arg.([]string)
	case 1:
		mc.Arg1 = arg.(string)
	default:
		panic("arg index out of range")
	}
}

func (mc *Test1AProxyC2Call) GetResult(resultIndex int) interface{} {
	switch resultIndex {
	case 0:
		return mc.Result0
	case 1:
		return mc.Result1
	default:
		panic("result index out of range")
	}
}

func (mc *Test1AProxyC2Call) SetResult(resultIndex int, result interface{}) {
	switch resultIndex {
	case 0:
		mc.Result0 = result.(float64)
	case 1:
		mc.Result1 = result.(float64)
	default:
		panic("result index out of range")
	}
}

func (mc *Test1AProxyC2Call) MethodName() string   { return "C2" }
func (mc *Test1AProxyC2Call) MethodIndex() int     { return Test1AProxyC2 }
func (mc *Test1AProxyC2Call) NumberOfArgs() int    { return 2 }
func (mc *Test1AProxyC2Call) NumberOfResults() int { return 2 }

func (mc *Test1AProxyC2Call) getNextInterceptor() (proxyz.MethodCallInterceptor, bool) {
	if i := mc.nextInterceptorIndex; i < len(mc.interceptors) {
		mc.nextInterceptorIndex++
		return mc.interceptors[i], true
	}

	return nil, false
}

func (p *Test1AProxy) C2(arg0 []string, _haha_ string) (float64, float64) {
	methodCallInterceptors := p.XxxGetMethodCallInterceptors(Test1AProxyC2)

	if len(methodCallInterceptors) == 0 {
		return p.Test1A.C2(arg0, _haha_)
	}

	methodCall := Test1AProxyC2Call{
		Arg0: arg0,
		Arg1: _haha_,

		callee:       p.Test1A,
		interceptors: methodCallInterceptors,
	}

	methodCall.Forward()
	return methodCall.Result0, methodCall.Result1
}

const Test1AProxyError = 4

type Test1AProxyErrorCall struct {
	Result0 string

	callee               *foo.Test1A
	interceptors         []proxyz.MethodCallInterceptor
	nextInterceptorIndex int
}

var _ = (proxyz.MethodCall)((*Test1AProxyErrorCall)(nil))

func (mc *Test1AProxyErrorCall) Forward() {
	if interceptor, ok := mc.getNextInterceptor(); ok {
		interceptor(mc)
		return
	}

	mc.Result0 = mc.callee.Error()
}

func (mc *Test1AProxyErrorCall) GetArg(argIndex int) interface{} {
	switch argIndex {
	default:
		panic("arg index out of range")
	}
}

func (mc *Test1AProxyErrorCall) SetArg(argIndex int, arg interface{}) {
	switch argIndex {
	default:
		panic("arg index out of range")
	}
}

func (mc *Test1AProxyErrorCall) GetResult(resultIndex int) interface{} {
	switch resultIndex {
	case 0:
		return mc.Result0
	default:
		panic("result index out of range")
	}
}

func (mc *Test1AProxyErrorCall) SetResult(resultIndex int, result interface{}) {
	switch resultIndex {
	case 0:
		mc.Result0 = result.(string)
	default:
		panic("result index out of range")
	}
}

func (mc *Test1AProxyErrorCall) MethodName() string   { return "Error" }
func (mc *Test1AProxyErrorCall) MethodIndex() int     { return Test1AProxyError }
func (mc *Test1AProxyErrorCall) NumberOfArgs() int    { return 0 }
func (mc *Test1AProxyErrorCall) NumberOfResults() int { return 1 }

func (mc *Test1AProxyErrorCall) getNextInterceptor() (proxyz.MethodCallInterceptor, bool) {
	if i := mc.nextInterceptorIndex; i < len(mc.interceptors) {
		mc.nextInterceptorIndex++
		return mc.interceptors[i], true
	}

	return nil, false
}

func (p *Test1AProxy) Error() string {
	methodCallInterceptors := p.XxxGetMethodCallInterceptors(Test1AProxyError)

	if len(methodCallInterceptors) == 0 {
		return p.Test1A.Error()
	}

	methodCall := Test1AProxyErrorCall{
		callee:       p.Test1A,
		interceptors: methodCallInterceptors,
	}

	methodCall.Forward()
	return methodCall.Result0
}

const Test1AProxyRead = 5

type Test1AProxyReadCall struct {
	Arg0    []byte
	Result0 int
	Result1 error

	callee               *foo.Test1A
	interceptors         []proxyz.MethodCallInterceptor
	nextInterceptorIndex int
}

var _ = (proxyz.MethodCall)((*Test1AProxyReadCall)(nil))

func (mc *Test1AProxyReadCall) Forward() {
	if interceptor, ok := mc.getNextInterceptor(); ok {
		interceptor(mc)
		return
	}

	mc.Result0, mc.Result1 = mc.callee.Read(mc.Arg0)
}

func (mc *Test1AProxyReadCall) GetArg(argIndex int) interface{} {
	switch argIndex {
	case 0:
		return mc.Arg0
	default:
		panic("arg index out of range")
	}
}

func (mc *Test1AProxyReadCall) SetArg(argIndex int, arg interface{}) {
	switch argIndex {
	case 0:
		mc.Arg0 = arg.([]byte)
	default:
		panic("arg index out of range")
	}
}

func (mc *Test1AProxyReadCall) GetResult(resultIndex int) interface{} {
	switch resultIndex {
	case 0:
		return mc.Result0
	case 1:
		return mc.Result1
	default:
		panic("result index out of range")
	}
}

func (mc *Test1AProxyReadCall) SetResult(resultIndex int, result interface{}) {
	switch resultIndex {
	case 0:
		mc.Result0 = result.(int)
	case 1:
		mc.Result1 = result.(error)
	default:
		panic("result index out of range")
	}
}

func (mc *Test1AProxyReadCall) MethodName() string   { return "Read" }
func (mc *Test1AProxyReadCall) MethodIndex() int     { return Test1AProxyRead }
func (mc *Test1AProxyReadCall) NumberOfArgs() int    { return 1 }
func (mc *Test1AProxyReadCall) NumberOfResults() int { return 2 }

func (mc *Test1AProxyReadCall) getNextInterceptor() (proxyz.MethodCallInterceptor, bool) {
	if i := mc.nextInterceptorIndex; i < len(mc.interceptors) {
		mc.nextInterceptorIndex++
		return mc.interceptors[i], true
	}

	return nil, false
}

func (p *Test1AProxy) Read(_p_ []byte) (int, error) {
	methodCallInterceptors := p.XxxGetMethodCallInterceptors(Test1AProxyRead)

	if len(methodCallInterceptors) == 0 {
		return p.Test1A.Read(_p_)
	}

	methodCall := Test1AProxyReadCall{
		Arg0: _p_,

		callee:       p.Test1A,
		interceptors: methodCallInterceptors,
	}

	methodCall.Forward()
	return methodCall.Result0, methodCall.Result1
}

func (p *Test1AProxy) XxxNumberOfMethods() int { return 6 }
