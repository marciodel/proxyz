package proxygen

import (
	"bytes"
	"fmt"
	"go/build"
	"path"
	"path/filepath"
	"reflect"
	"sort"
	"strconv"
	"text/template"

	"golang.org/x/tools/go/packages"

	"github.com/roy2220/proxyz/cmd/proxyz/internal/methodset"
)

// ProxyGen ...
type ProxyGen struct {
	MethodSet            *methodset.MethodSet
	OutputPackagePattern string
	OutputTypeName       string

	buffer               bytes.Buffer
	outputPackageDirPath string
	outputPackageName    string
	outputPackagePath    string
	importPath2FormatArg map[string]string
}

// EmitProgram ...
func (pg *ProxyGen) EmitProgram() ([]byte, error) {
	var err error
	pg.outputPackageDirPath, err = locatePackageDir(pg.OutputPackagePattern)

	if err != nil {
		return nil, err
	}

	if pg.OutputPackagePattern == pg.inputPackagePattern() {
		pg.outputPackageName, pg.outputPackagePath = pg.inputPackageName(), pg.inputPackagePath()
	} else {
		var err error
		pg.outputPackageName, pg.outputPackagePath, err = findPackageNameAndPath(pg.OutputPackagePattern)

		if err != nil {
			return nil, err
		}

		if pg.outputPackageName == "" {
			pg.outputPackageName = path.Base(pg.outputPackageDirPath)
		}
	}

	pg.emitPackageClause()
	pg.emitImportDeclaration()
	pg.emitTypeDeclaration()
	pg.emitMethodDeclarations()
	return pg.buffer.Bytes(), nil
}

// OutputPackageDirPath ...
func (pg *ProxyGen) OutputPackageDirPath() string {
	return pg.outputPackageDirPath
}

func (pg *ProxyGen) emitPackageClause() {
	fmt.Fprintln(&pg.buffer, "// Code generated by proxyz. DO NOT EDIT.")
	fmt.Fprintf(&pg.buffer, "package %s\n", pg.outputPackageName)
}

func (pg *ProxyGen) emitImportDeclaration() {
	packageBasicInfos := []methodset.PackageBasicInfo{
		{Name: "proxyz", ImportPath: "github.com/roy2220/proxyz"},
		{Name: pg.inputPackageName(), Path: pg.inputPackagePath(), ImportPath: pg.inputImportPath()},
	}

	for _, method := range pg.MethodSet.Methods {
		for _, argType := range method.ArgTypes {
			packageBasicInfos = append(packageBasicInfos, argType.PackageBasicInfos...)
		}

		for _, resultType := range method.ResultTypes {
			packageBasicInfos = append(packageBasicInfos, resultType.PackageBasicInfos...)
		}
	}

	importPath2ImportName := make(map[string]string)

	importNames := map[string]struct{}{
		pg.outputPackageName: {},
	}

	for _, packageBasicInfo := range packageBasicInfos {
		if packageBasicInfo.Path == pg.outputPackagePath {
			continue
		}

		packageName, importPath := packageBasicInfo.Name, packageBasicInfo.ImportPath

		if _, ok := importPath2ImportName[importPath]; ok {
			continue
		}

		importName := packageName

		if _, ok := importNames[importName]; ok {
			for i := 1; ; i++ {
				importName = packageName + strconv.Itoa(i)

				if _, ok := importNames[importName]; !ok {
					break
				}
			}
		}

		importPath2ImportName[importPath] = importName
		importNames[importName] = struct{}{}
	}

	if len(importPath2ImportName) == 0 {
		return
	}

	orderedImportPaths := make([]string, len(importPath2ImportName))
	var i int

	for importPath := range importPath2ImportName {
		orderedImportPaths[i] = importPath
		i++
	}

	sort.Strings(orderedImportPaths)
	fmt.Fprintln(&pg.buffer, "")
	fmt.Fprintln(&pg.buffer, "import (")

	for _, importPath := range orderedImportPaths {
		importName := importPath2ImportName[importPath]
		fmt.Fprintf(&pg.buffer, "\t%s %q\n", importName, importPath)
	}

	fmt.Fprintln(&pg.buffer, ")")
	pg.importPath2FormatArg = make(map[string]string)

	for importPath, importName := range importPath2ImportName {
		pg.importPath2FormatArg[importPath] = importName + "."
	}
}

func (pg *ProxyGen) emitTypeDeclaration() {
	const text = `
type {{ $.TypeName }} struct {
	proxyz.XxxProxyBase
	{{ $.UnderlyingType }}
}

var _ = (proxyz.Proxy)((*{{ $.TypeName }})(nil))

func {{ $.NewFunctionName }}(underlying {{ $.UnderlyingType }}) *{{ $.TypeName }} {
	return &{{ $.TypeName }}{
		{{ $.UnderlyingTypeName }}: underlying,
	}
}
`
	var newFunctionName string

	if outputTypeName2 := capitalizeFirstLetter(pg.OutputTypeName); pg.OutputTypeName == outputTypeName2 {
		newFunctionName = "New" + pg.OutputTypeName
	} else {
		newFunctionName = "new" + outputTypeName2
	}

	data := struct {
		TypeName           string
		UnderlyingType     string
		UnderlyingTypeName string
		NewFunctionName    string
	}{
		TypeName:           pg.OutputTypeName,
		UnderlyingType:     pg.formatInputType(),
		UnderlyingTypeName: pg.inputTypeName(),
		NewFunctionName:    newFunctionName,
	}

	if err := template.Must(template.New("").Parse(text)).Execute(&pg.buffer, data); err != nil {
		panic(err)
	}
}

func (pg *ProxyGen) emitMethodDeclarations() {
	orderedMethods := make([]methodset.Method, len(pg.MethodSet.Methods))
	copy(orderedMethods, pg.MethodSet.Methods)

	sort.Slice(orderedMethods, func(i, j int) bool {
		return orderedMethods[i].Name < orderedMethods[j].Name
	})

	for i, method := range orderedMethods {
		pg.emitMethodDeclaration(method, i)
	}

	const text = `
func (p *{{ $.TypeName }}) XxxGetMethodName(methodIndex int) string {
	return [...]string{
{{- range $i, $methodName := $.MethodNames }}
		{{ $.TypeName }}{{ $methodName }}: "{{ $methodName }}",
{{- end }}
	}[methodIndex]
}

func (p *{{ $.TypeName }}) XxxNumberOfMethods() int { return {{ len $.MethodNames }} }
func (p *{{ $.TypeName }}) XxxUnderlyingType() string { return "{{ $.UnderlyingTypeRepr }}" }
`
	methodNames := make([]string, len(orderedMethods))

	for i := range orderedMethods {
		methodNames[i] = orderedMethods[i].Name
	}

	data := struct {
		TypeName           string
		MethodNames        []string
		UnderlyingTypeRepr string
	}{
		TypeName:           pg.OutputTypeName,
		MethodNames:        methodNames,
		UnderlyingTypeRepr: pg.inputPackagePath() + "." + pg.inputTypeName(),
	}

	if err := template.Must(template.New("").Parse(text)).Execute(&pg.buffer, data); err != nil {
		panic(err)
	}
}

func (pg *ProxyGen) emitMethodDeclaration(method methodset.Method, methodIndex int) {
	funcMap := template.FuncMap{
		"last": func(i int, a interface{}) bool {
			return i == reflect.ValueOf(a).Len()-1
		},
	}

	const text = `
const {{ $.TypeName }}{{ $.MethodName }} = {{ $.MethodIndex }}

type {{ $.TypeName }}{{ $.MethodName }}Call struct {
{{- range $i, $argType := $.ArgTypes }}
	Arg{{ $i }}{{ " " }}
	{{- if and $.MethodIsVariadic (last $i $.ArgTypes) }}
		{{- "[]" }}
	{{- end }}
	{{- $argType }}
{{- end }}
{{- range $i, $resultType := $.ResultTypes }}
	Result{{ $i }} {{ $resultType }}
{{- end }}
{{- if or $.ArgTypes $.ResultTypes }}
{{ "" }}
{{- end }}
	callee {{ $.UnderlyingType }}
	interceptors []proxyz.MethodCallInterceptor
	nextInterceptorIndex int
}

var _ = (proxyz.MethodCall)((*{{ $.TypeName }}{{ $.MethodName }}Call)(nil))

func (mc *{{ $.TypeName }}{{ $.MethodName }}Call) Forward() {
	if interceptor, ok := mc.getNextInterceptor(); ok {
		interceptor(mc)
		return
	}

	{{ "" }}
{{- if $.ResultTypes }}
	{{- range $i, $_ := $.ResultTypes }}
		{{- if $i }}
			{{- ", " }}
		{{- end }}
		{{- "mc.Result" }}{{ $i }}
	{{- end }}
	{{- " = " }}
{{- end }}
{{- "mc.callee" }}.{{ $.MethodName }}(
{{- range $i, $_ := $.ArgTypes }}
	{{- if $i }}
		{{- ", " }}
	{{- end }}
	{{- "mc.Arg" }}{{ $i }}
	{{- if and $.MethodIsVariadic (last $i $.ArgTypes) }}
		{{- "..." }}
	{{- end }}
{{- end }}
{{- ")" }}
}

func (mc *{{ $.TypeName }}{{ $.MethodName }}Call) GetArg(argIndex int) interface{} {
	switch argIndex {
{{- range $i, $_ := $.ArgTypes }}
	case {{ $i }}:
		return mc.Arg{{ $i }}
{{- end }}
	default:
		panic("arg index out of range")
	}
}

func (mc *{{ $.TypeName }}{{ $.MethodName }}Call) SetArg(argIndex int, arg interface{}) {
	switch argIndex {
{{- range $i, $argType := $.ArgTypes }}
	case {{ $i }}:
		mc.Arg{{ $i }} = arg.(
	{{- if and $.MethodIsVariadic (last $i $.ArgTypes) }}
		{{- "[]" }}
	{{- end }}
	{{- $argType }}
	{{- ")"}}
{{- end }}
	default:
		panic("arg index out of range")
	}
}

func (mc *{{ $.TypeName }}{{ $.MethodName }}Call) GetResult(resultIndex int) interface{} {
	switch resultIndex {
{{- range $i, $_ := $.ResultTypes }}
	case {{ $i }}:
		return mc.Result{{ $i }}
{{- end }}
	default:
		panic("result index out of range")
	}
}

func (mc *{{ $.TypeName }}{{ $.MethodName }}Call) SetResult(resultIndex int, result interface{}) {
	switch resultIndex {
{{- range $i, $resultType := $.ResultTypes }}
	case {{ $i }}:
		mc.Result{{ $i }} = result.({{ $resultType }})
{{- end }}
	default:
		panic("result index out of range")
	}
}

func (mc *{{ $.TypeName }}{{ $.MethodName }}Call) MethodName() string { return "{{ $.MethodName }}" }
func (mc *{{ $.TypeName }}{{ $.MethodName }}Call) MethodIndex() int { return {{ $.TypeName }}{{ $.MethodName }} }
func (mc *{{ $.TypeName }}{{ $.MethodName }}Call) NumberOfArgs() int { return {{ len $.ArgTypes }} }
func (mc *{{ $.TypeName }}{{ $.MethodName }}Call) NumberOfResults() int { return {{ len $.ResultTypes }} }

func (mc *{{ $.TypeName }}{{ $.MethodName }}Call) getNextInterceptor() (proxyz.MethodCallInterceptor, bool) {
	if i := mc.nextInterceptorIndex; i < len(mc.interceptors) {
		mc.nextInterceptorIndex++
		return mc.interceptors[i], true
	}

	return nil, false
}

func (p *{{ $.TypeName }}) {{ $.MethodName }}(
{{- range $i, $argType := $.ArgTypes }}
	{{- if $i }}
		{{- ", " }}
	{{- end }}
	{{- index $.ArgNames $i }}{{ " " }}
	{{- if and $.MethodIsVariadic (last $i $.ArgTypes) }}
		{{- "..." }}
	{{- end }}
	{{- $argType }}
{{- end }}
{{- ")" }}
{{- if $.ResultTypes }}
	{{- " " }}
	{{- if ge (len $.ResultTypes) 2 }}
	{{- "(" }}
	{{- end }}
	{{- range $i, $resultType := $.ResultTypes }}
		{{- if $i }}
			{{- ", " }}
		{{- end }}
		{{- $resultType }}
	{{- end }}
	{{- if ge (len $.ResultTypes) 2 }}
	{{- ")" }}
	{{- end }}
{{- end }}
{{- " {" }}
	methodCallInterceptors := p.XxxGetMethodCallInterceptors({{ $.TypeName }}{{ $.MethodName }})

	if len(methodCallInterceptors) == 0 {
		{{ "" }}
{{- if $.ResultTypes }}
{{- "return " }}
{{- end }}
{{- "p." }}{{ $.UnderlyingTypeName }}.{{ $.MethodName }}(
{{- range $i, $_ := $.ArgTypes }}
	{{- if $i }}
		{{- ", " }}
	{{- end }}
	{{- index $.ArgNames $i }}
	{{- if and $.MethodIsVariadic (last $i $.ArgTypes) }}
		{{- "..." }}
	{{- end }}
{{- end }}
{{- ")" }}
	}

	methodCall := {{ $.TypeName }}{{ $.MethodName }}Call{
{{- range $i, $_ := $.ArgTypes }}
		Arg{{ $i }}: {{ index $.ArgNames $i }},
{{- end }}
{{- if $.ArgTypes }}
{{ "" }}
{{- end }}
		callee: p.{{ $.UnderlyingTypeName }},
		interceptors: methodCallInterceptors,
	}

	methodCall.Forward()
{{- if $.ResultTypes }}
	{{ "return " }}
	{{- range $i, $_ := $.ResultTypes }}
		{{- if $i }}
			{{- ", " }}
		{{- end }}
		{{- "methodCall.Result" }}{{ $i }}
	{{- end }}
{{- end }}
}
`

	argNames := make([]string, len(method.ArgTypes))
	copy(argNames, method.ArgNames)

	for i, argName := range argNames {
		switch argName {
		case "", "_":
			argNames[i] = "arg" + strconv.Itoa(i)
		default:
			argNames[i] = "_" + argName + "_"
		}
	}

	argTypes := make([]string, len(method.ArgTypes))

	for i, argType := range method.ArgTypes {
		argTypes[i] = pg.formatType(argType)
	}

	resultTypes := make([]string, len(method.ResultTypes))

	for i, resultType := range method.ResultTypes {
		resultTypes[i] = pg.formatType(resultType)
	}

	data := struct {
		TypeName           string
		UnderlyingType     string
		UnderlyingTypeName string
		MethodName         string
		MethodIsVariadic   bool
		MethodIndex        int
		ArgNames           []string
		ArgTypes           []string
		ResultTypes        []string
	}{
		TypeName:           pg.OutputTypeName,
		UnderlyingType:     pg.formatInputType(),
		UnderlyingTypeName: pg.inputTypeName(),
		MethodName:         method.Name,
		MethodIsVariadic:   method.IsVariadic,
		MethodIndex:        methodIndex,
		ArgNames:           argNames,
		ArgTypes:           argTypes,
		ResultTypes:        resultTypes,
	}

	if err := template.Must(template.New("").Funcs(funcMap).Parse(text)).Execute(&pg.buffer, data); err != nil {
		panic(err)
	}
}

func (pg *ProxyGen) formatType(type1 methodset.Type) string {
	formatArgs := make([]interface{}, len(type1.PackageBasicInfos))

	for i, packageBasicInfo := range type1.PackageBasicInfos {
		formatArgs[i] = pg.formatArg(packageBasicInfo.ImportPath)
	}

	return fmt.Sprintf(type1.Format, formatArgs...)
}

func (pg *ProxyGen) formatInputType() string {
	var prefix string

	if !pg.MethodSet.TypeIsInterface {
		prefix = "*"
	}

	return fmt.Sprintf("%s%s%s", prefix, pg.formatArg(pg.inputImportPath()), pg.inputTypeName())
}

func (pg *ProxyGen) inputPackagePattern() string {
	return pg.MethodSet.TypeName
}

func (pg *ProxyGen) inputTypeName() string {
	return pg.MethodSet.TypeName
}

func (pg *ProxyGen) inputPackageName() string {
	return pg.MethodSet.PackageName
}

func (pg *ProxyGen) inputPackagePath() string {
	return pg.MethodSet.PackagePath
}

func (pg *ProxyGen) inputImportPath() string {
	return pg.MethodSet.ImportPath
}

func (pg *ProxyGen) formatArg(importPath string) string {
	return pg.importPath2FormatArg[importPath]
}

func locatePackageDir(packagePattern string) (string, error) {
	rawPackage, err := build.Import(packagePattern, ".", build.FindOnly)

	if err != nil {
		return "", fmt.Errorf("proxygen: package import failed; packagePattern=%q: %v", packagePattern, err)
	}

	packageDirPath, err := filepath.Abs(rawPackage.Dir)

	if err != nil {
		return "", fmt.Errorf("proxygen: absolute path fetch failed; path=%q: %v", rawPackage.Dir, err)
	}

	return packageDirPath, nil
}

func findPackageNameAndPath(packagePattern string) (string, string, error) {
	rawPackages, err := packages.Load(&packages.Config{
		Mode: packages.NeedName,
	}, packagePattern)

	if err != nil {
		return "", "", fmt.Errorf("proxygen: package load failed; packagePattern=%q: %v", packagePattern, err)
	}

	if n := len(rawPackages); n != 1 {
		var err error

		if n == 0 {
			err = fmt.Errorf("proxygen: no package found; packagePattern=%q", packagePattern)
		} else {
			packagePaths := make([]string, n)

			for i, rawPackage := range rawPackages {
				packagePaths[i] = rawPackage.PkgPath
			}

			err = fmt.Errorf("proxygen: multiple packages found; packagePattern=%q packagePaths=%q", packagePattern, packagePaths)
		}

		return "", "", err
	}

	rawPackage := rawPackages[0]
	return rawPackage.Name, rawPackage.PkgPath, nil
}

func capitalizeFirstLetter(word string) string {
	if c := word[0]; c >= 'a' && c <= 'z' {
		return string('A'+(c-'a')) + word[1:]
	}

	return word
}
